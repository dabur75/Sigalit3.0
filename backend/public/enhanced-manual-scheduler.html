<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>מדריך שיבוץ משופר - סיגלית</title>
    
    <!-- Include header functions -->
    <script src="header-functions.js"></script>
    <script src="jewish-holidays-service.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* CSS Animations for Enhanced UI Polish */
        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideInLeft {
            from {
                opacity: 0;
                transform: translateX(-30px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(30px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-10px);
            }
            60% {
                transform: translateY(-5px);
            }
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(124, 58, 237, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(124, 58, 237, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(124, 58, 237, 0);
            }
        }

        @keyframes shimmer {
            0% {
                background-position: -200px 0;
            }
            100% {
                background-position: calc(200px + 100%) 0;
            }
        }

        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, 'Roboto', sans-serif;
            background: #f8fafc;
            min-height: 100vh;
            direction: rtl;
            color: #334155;
            overflow-x: auto;
            animation: fadeIn 0.5s ease-out;
        }

        /* Header and Navigation */
        .main-container {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #7c3aed, #a855f7);
            color: white;
            padding: 20px 40px;
            box-shadow: 0 4px 20px rgba(124, 58, 237, 0.3);
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1600px;
            margin: 0 auto;
        }

        .header-title {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .header-title h1 {
            font-size: 1.8rem;
            font-weight: 600;
            margin: 0;
        }

        .header-title .icon {
            font-size: 2rem;
        }

        .header-nav {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .nav-button {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 16px;
            border-radius: 6px;
            text-decoration: none;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        .nav-button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        /* Main Content Area */
        .content-wrapper {
            flex: 1;
            padding: 20px;
            max-width: 1600px;
            margin: 0 auto;
            width: 100%;
        }

        /* Month Navigation */
        .month-navigation {
            background: white;
            border-radius: 12px;
            padding: 20px 30px;
            margin-bottom: 20px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
            display: flex;
            justify-content: space-between;
            align-items: center;
            animation: slideInUp 0.4s ease-out;
        }

        .month-controls {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .month-button {
            background: #8b5cf6;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 10px 20px;
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .month-button:hover:not(:disabled) {
            background: #7c3aed;
            transform: translateY(-1px);
        }

        .month-button:disabled {
            background: #cbd5e1;
            color: #94a3b8;
            cursor: not-allowed;
            transform: none;
        }

        .current-month-display {
            font-size: 1.4rem;
            font-weight: 600;
            color: #7c3aed;
            min-width: 200px;
            text-align: center;
        }

        .month-info {
            display: flex;
            gap: 20px;
            align-items: center;
            color: #64748b;
            font-size: 0.9rem;
        }

        /* Action Buttons */
        .action-buttons {
            background: white;
            border-radius: 12px;
            padding: 20px 30px;
            margin-bottom: 20px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .action-button {
            background: #10b981;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 20px;
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .action-button:hover:not(:disabled) {
            background: #059669;
            transform: translateY(-1px);
        }

        .action-button:disabled {
            background: #cbd5e1;
            color: #94a3b8;
            cursor: not-allowed;
            transform: none;
        }

        .action-button.secondary {
            background: #6b7280;
        }

        .action-button.secondary:hover:not(:disabled) {
            background: #4b5563;
        }

        .action-button.danger {
            background: #ef4444;
        }

        .action-button.danger:hover:not(:disabled) {
            background: #dc2626;
        }

        /* Guide Cards Container */
        .guides-section {
            background: white;
            border-radius: 12px;
            padding: 20px 30px;
            margin-bottom: 20px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
        }

        .guides-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .guides-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #374151;
        }

        .guides-info {
            color: #6b7280;
            font-size: 0.9rem;
        }

        .guides-container {
            display: flex;
            gap: 15px;
            overflow-x: auto;
            padding: 10px 0;
            min-height: 120px;
            animation: slideInLeft 0.6s ease-out;
            scroll-behavior: smooth;
        }

        /* Guide Cards */
        .guide-card {
            background: #ffffff;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            padding: 15px;
            min-width: 140px;
            cursor: grab;
            transition: all 0.2s ease;
            user-select: none;
            position: relative;
        }

        .guide-card:hover {
            border-color: #8b5cf6;
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 6px 20px rgba(139, 92, 246, 0.25);
            animation: pulse 2s infinite;
        }

        .guide-card.selected {
            border-color: #7c3aed;
            background: #f3f4f6;
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(124, 58, 237, 0.3);
        }

        .guide-card.dragging {
            opacity: 0.8;
            transform: rotate(5deg);
            cursor: grabbing;
            z-index: 1000;
        }

        .guide-card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #d1d5db;
        }

        .guide-name {
            font-weight: 600;
            color: #374151;
            margin-bottom: 8px;
            text-align: center;
        }

        .guide-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .shift-counter {
            background: #8b5cf6;
            color: white;
            border-radius: 12px;
            padding: 4px 8px;
            font-size: 0.8rem;
            font-weight: 600;
            min-width: 24px;
            text-align: center;
        }

        .salary-hours {
            color: #6b7280;
            font-size: 0.85rem;
            text-align: center;
            margin-top: 4px;
        }

        .guide-constraints-indicator {
            position: absolute;
            top: -8px;
            left: -8px;
            background: #ef4444;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 0.7rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
        }

        /* Calendar Section */
        .calendar-section {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
            margin-bottom: 20px;
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
        }

        .calendar-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #374151;
        }

        .calendar-legend {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.85rem;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }

        /* Calendar Grid */
        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 1px;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid #e5e7eb;
            background: #e5e7eb;
            animation: slideInRight 0.7s ease-out;
        }

        .calendar-day-header {
            background: #8b5cf6;
            color: white;
            padding: 12px 8px;
            text-align: center;
            font-weight: 600;
            font-size: 0.9rem;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .calendar-day-header.weekend-header {
            background: #7c3aed;
            box-shadow: inset 0 0 0 2px #fbbf24;
        }
        
        .day-short {
            font-size: 1rem;
            font-weight: 700;
        }
        
        .day-full {
            font-size: 0.7rem;
            opacity: 0.8;
            margin-top: 2px;
        }

        .calendar-day {
            background: white;
            min-height: 120px;
            padding: 0;
            position: relative;
            border: 2px solid transparent;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .calendar-day:hover {
            background: #f8fafc;
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
            z-index: 10;
        }

        .calendar-day.other-month {
            background: #f3f4f6;
            color: #9ca3af;
            opacity: 0.6;
        }

        .calendar-day.today {
            background: #eff6ff;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        /* Israeli weekend styling */
        .calendar-day.weekend {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            border-left: 3px solid #f59e0b;
        }
        
        .calendar-day.friday {
            background: linear-gradient(135deg, #ddd6fe 0%, #c4b5fd 100%);
            border-left: 3px solid #8b5cf6;
        }
        
        .calendar-day.saturday {
            background: linear-gradient(135deg, #e0e7ff 0%, #c7d2fe 100%);
            border-left: 3px solid #6366f1;
        }

        .calendar-day.closed-weekend {
            background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%);
            border-left: 3px solid #ef4444;
        }
        
        .calendar-day.holiday {
            background: linear-gradient(135deg, #ecfdf5 0%, #d1fae5 100%);
            border-left: 3px solid #10b981;
        }

        .calendar-day.drop-target {
            border-color: #10b981;
            background: #ecfdf5;
        }

        .calendar-day.drop-invalid {
            border-color: #ef4444;
            background: #fef2f2;
        }

        .calendar-day.has-constraint {
            background: #fff1f2;
            border-color: #f87171;
        }

        /* Enhanced Day Structure */
        .day-header {
            padding: 6px 8px;
            background: rgba(255, 255, 255, 0.9);
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-height: 30px;
        }
        
        .day-number {
            font-weight: 600;
            font-size: 0.9rem;
            color: #374151;
        }
        
        .day-indicators {
            display: flex;
            gap: 4px;
            align-items: center;
        }
        
        .today-indicator {
            color: #3b82f6;
            font-size: 0.8rem;
        }
        
        .holiday-indicator {
            font-size: 0.8rem;
            margin-left: 2px;
            display: inline-block;
            line-height: 1;
        }
        
        .holiday-title {
            font-size: 0.7rem;
            color: #d97706;
            font-weight: 600;
            text-align: center;
            margin: 2px 0;
            line-height: 1.2;
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .closed-indicator {
            font-size: 0.7rem;
        }
        
        .day-slots {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 2px;
            padding: 4px;
        }
        
        .day-slot {
            flex: 1;
            border: 1px solid #e5e7eb;
            border-radius: 4px;
            padding: 4px;
            min-height: 30px;
            display: flex;
            flex-direction: column;
            position: relative;
            transition: all 0.2s ease;
            cursor: pointer;
        }
        
        .day-slot:hover {
            border-color: #8b5cf6;
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(139, 92, 246, 0.2);
            z-index: 5;
        }
        
        .normal-slot {
            background: #f8fafc;
            border-color: #8b5cf6;
        }
        
        .overlap-slot {
            background: #fffbeb;
            border-color: #f59e0b;
        }
        
        .slot-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2px;
        }
        
        .slot-label {
            font-size: 0.7rem;
            font-weight: 600;
            color: #6b7280;
        }
        
        .slot-type-icon {
            font-size: 0.7rem;
        }
        
        .slot-content {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 20px;
        }
        
        .assignment-placeholder {
            font-size: 0.6rem;
            color: #9ca3af;
            text-align: center;
            font-style: italic;
        }
        
        .slot-actions {
            display: none;
            position: absolute;
            top: 2px;
            right: 2px;
        }
        
        .day-slot:hover .slot-actions {
            display: block;
        }
        
        .remove-assignment {
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            font-size: 0.7rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .day-footer {
            padding: 4px 8px;
            background: rgba(0, 0, 0, 0.02);
            border-top: 1px solid #e5e7eb;
            min-height: 20px;
        }
        
        .day-stats {
            text-align: center;
            font-size: 0.7rem;
            color: #6b7280;
        }
        
        /* Enhanced drop zone states */
        .day-slot.drop-zone {
            border: 2px dashed #10b981;
            background: #ecfdf5;
            box-shadow: inset 0 0 0 1px #10b981;
        }
        
        .day-slot.drop-hover {
            border-color: #059669;
            background: #d1fae5;
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }
        
        .day-slot.drop-enter {
            animation: dropEnter 0.2s ease;
        }
        
        .day-slot.drop-invalid {
            border: 2px dashed #ef4444;
            background: #fef2f2;
            box-shadow: inset 0 0 0 1px #ef4444;
        }
        
        .day-slot.drop-success {
            border-color: #10b981;
            background: #d1fae5;
            animation: dropSuccess 0.5s ease;
        }
        
        .day-slot.occupied {
            background: #f3f4f6;
            border-color: #6b7280;
            cursor: default;
        }
        
        .day-slot.occupied:hover {
            transform: none;
        }
        
        @keyframes dropEnter {
            0% { transform: scale(1); }
            50% { transform: scale(1.08); }
            100% { transform: scale(1.05); }
        }
        
        @keyframes dropSuccess {
            0% { transform: scale(1.05); background: #d1fae5; }
            50% { transform: scale(1.1); background: #a7f3d0; }
            100% { transform: scale(1); background: #f3f4f6; }
        }
        
        /* Assignment Display */
        .assignment-display {
            text-align: center;
            width: 100%;
        }
        
        .assigned-guide-name {
            font-size: 0.7rem;
            font-weight: 600;
            color: #374151;
            margin-bottom: 2px;
        }
        
        .assigned-guide-role {
            font-size: 0.6rem;
            color: #6b7280;
            font-style: italic;
        }
        
        .day-slot.occupied .assignment-display {
            background: rgba(139, 92, 246, 0.1);
            border-radius: 3px;
            padding: 4px;
        }
        
        .normal-slot.occupied .assignment-display {
            background: rgba(139, 92, 246, 0.15);
            border: 1px solid rgba(139, 92, 246, 0.3);
        }
        
        .overlap-slot.occupied .assignment-display {
            background: rgba(245, 158, 11, 0.15);
            border: 1px solid rgba(245, 158, 11, 0.3);
        }
        
        /* Enhanced Constraint Visualization */
        .constraint-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.8;
        }
        
        .constraint-overlay-regular {
            background: linear-gradient(45deg, #fee2e2 25%, transparent 25%),
                        linear-gradient(-45deg, #fee2e2 25%, transparent 25%);
            background-size: 8px 8px;
            border: 2px solid #dc2626;
        }
        
        .constraint-overlay-fixed {
            background: linear-gradient(90deg, #fef3c7 50%, transparent 50%);
            background-size: 6px 6px;
            border: 2px solid #d97706;
        }
        
        .constraint-overlay-vacation {
            background: linear-gradient(135deg, #ecfdf5 25%, #d1fae5 25%, #d1fae5 50%, #ecfdf5 50%);
            background-size: 10px 10px;
            border: 2px solid #059669;
        }
        
        .constraint-overlay-dynamic {
            background: linear-gradient(45deg, #fce7f3 30%, transparent 30%),
                        linear-gradient(-45deg, #fce7f3 30%, transparent 30%);
            background-size: 12px 12px;
            border: 2px solid #be185d;
        }
        
        .constraint-icon {
            font-size: 1.2rem;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
            z-index: 11;
        }
        
        .constraint-info {
            position: absolute;
            top: 4px;
            right: 4px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 2px 6px;
            border-radius: 12px;
            font-size: 0.6rem;
            z-index: 12;
            cursor: pointer;
            transition: all 0.2s ease;
            max-width: 80%;
            text-align: center;
        }
        
        .constraint-info:hover {
            background: rgba(0, 0, 0, 0.9);
            transform: scale(1.1);
        }
        
        .constraint-info-regular {
            background: rgba(220, 38, 38, 0.9);
        }
        
        .constraint-info-fixed {
            background: rgba(217, 119, 6, 0.9);
        }
        
        .constraint-info-vacation {
            background: rgba(5, 150, 105, 0.9);
        }
        
        .constraint-info-dynamic {
            background: rgba(190, 24, 93, 0.9);
        }
        
        .constraint-type-label {
            font-weight: 600;
            display: block;
        }
        
        .constraint-reason-short {
            font-size: 0.5rem;
            opacity: 0.9;
            display: block;
            margin-top: 1px;
        }
        
        /* Slot constraint styling */
        .slot-has-constraint {
            opacity: 0.7;
            cursor: not-allowed;
        }
        
        .slot-constraint-regular {
            border-color: #dc2626;
            background: #fee2e2;
        }
        
        .slot-constraint-fixed {
            border-color: #d97706;
            background: #fef3c7;
        }
        
        .slot-constraint-vacation {
            border-color: #059669;
            background: #ecfdf5;
        }
        
        .slot-constraint-dynamic {
            border-color: #be185d;
            background: #fce7f3;
        }
        
        .constraint-blocked {
            position: relative;
        }
        
        .constraint-blocked::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                45deg,
                transparent,
                transparent 2px,
                rgba(220, 38, 38, 0.3) 2px,
                rgba(220, 38, 38, 0.3) 4px
            );
            pointer-events: none;
        }
        
        /* Constraint legend enhancement */
        .constraint-legend {
            display: flex;
            gap: 15px;
            margin: 10px 0;
            padding: 10px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }
        
        .legend-constraint-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.8rem;
        }
        
        .legend-constraint-icon {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
        }
        
        .legend-constraint-icon.regular {
            background: #fee2e2;
            border: 1px solid #dc2626;
        }
        
        .legend-constraint-icon.fixed {
            background: #fef3c7;
            border: 1px solid #d97706;
        }
        
        .legend-constraint-icon.vacation {
            background: #ecfdf5;
            border: 1px solid #059669;
        }
        
        .legend-constraint-icon.dynamic {
            background: #fce7f3;
            border: 1px solid #be185d;
        }

        .day-slots {
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-height: 60px;
        }

        .day-slot {
            background: #f8fafc;
            border: 1px dashed #d1d5db;
            border-radius: 6px;
            padding: 6px;
            min-height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            color: #6b7280;
            transition: all 0.2s ease;
        }

        .day-slot.normal-slot {
            border-color: #8b5cf6;
        }

        .day-slot.overlap-slot {
            border-color: #f59e0b;
        }

        .day-slot.occupied {
            background: #8b5cf6;
            color: white;
            border-style: solid;
        }

        .day-slot.overlap-occupied {
            background: #f59e0b;
            color: white;
            border-style: solid;
        }

        .day-slot.drop-zone {
            border-color: #10b981;
            background: #ecfdf5;
            border-style: solid;
        }

        .day-slot.drop-invalid {
            border-color: #ef4444;
            background: #fef2f2;
            border-style: solid;
        }

        .slot-label {
            font-size: 0.7rem;
            opacity: 0.7;
        }

        .assigned-guide {
            font-weight: 600;
            color: inherit;
        }

        /* Constraint Visualization */
        .constraint-overlay {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            background: repeating-linear-gradient(
                45deg,
                rgba(239, 68, 68, 0.1),
                rgba(239, 68, 68, 0.1) 10px,
                transparent 10px,
                transparent 20px
            );
            pointer-events: none;
            border-radius: 6px;
        }

        .constraint-info {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: 0.7rem;
            color: #ef4444;
            font-weight: 600;
        }

        /* Status and Loading */
        .status-bar {
            background: white;
            border-radius: 12px;
            padding: 15px 25px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .status-info {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.9rem;
        }

        .status-icon {
            font-size: 1rem;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 40px;
            color: #64748b;
        }

        .loading.active {
            display: block;
        }

        .loading-spinner {
            border: 3px solid #f3f4f6;
            border-top: 3px solid #8b5cf6;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .content-wrapper {
                padding: 15px;
            }
            
            .calendar-section {
                padding: 20px;
            }
            
            .calendar-day {
                min-height: 80px;
            }
            
            .guides-container {
                flex-wrap: wrap;
            }
            
            .guide-card {
                min-width: 120px;
            }
        }

        @media (max-width: 768px) {
            .header {
                padding: 15px 20px;
            }
            
            .header-content {
                flex-direction: column;
                gap: 15px;
            }
            
            .header-nav {
                gap: 10px;
            }
            
            .month-navigation {
                padding: 15px 20px;
                flex-direction: column;
                gap: 15px;
            }
            
            .month-controls {
                gap: 15px;
            }
            
            .current-month-display {
                font-size: 1.2rem;
            }
            
            .action-buttons {
                padding: 15px 20px;
                justify-content: center;
            }
            
            .guides-section {
                padding: 15px 20px;
            }
            
            .calendar-section {
                padding: 15px;
            }
            
            .calendar-day {
                min-height: 70px;
                padding: 4px;
            }
            
            .guide-card {
                min-width: 100px;
                padding: 12px;
            }
        }

        /* Animation and Transitions */
        .fade-in {
            animation: fadeIn 0.3s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .slide-in {
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from { transform: translateX(20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        /* Drag and Drop Visual Feedback */
        .drag-ghost {
            position: fixed;
            pointer-events: none;
            z-index: 10000;
            transform: rotate(5deg);
            opacity: 0.9;
        }
        
        /* Mobile Touch Support Styles */
        .touch-ghost {
            border: 2px solid #007bff;
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
        }
        
        .touch-ghost .touch-indicator {
            position: absolute;
            top: -10px;
            right: -10px;
            background: #28a745;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
        }
        
        .guide-card.touch-dragging {
            opacity: 0.5;
            transform: scale(0.95);
            transition: all 0.2s ease;
        }
        
        .day-slot.touch-drop-target {
            border-color: #007bff !important;
            border-width: 3px !important;
            background-color: rgba(0, 123, 255, 0.1) !important;
            box-shadow: 0 0 10px rgba(0, 123, 255, 0.3);
            animation: pulse-blue 0.5s infinite alternate;
        }
        
        @keyframes pulse-blue {
            0% { box-shadow: 0 0 10px rgba(0, 123, 255, 0.3); }
            100% { box-shadow: 0 0 20px rgba(0, 123, 255, 0.6); }
        }
        
        /* Touch-friendly sizing for mobile */
        @media (max-width: 768px) {
            .guide-card {
                min-height: 60px;
                touch-action: none;
            }
            
            .day-slot {
                min-height: 40px;
                touch-action: none;
            }
            
            .drag-ghost {
                transform: scale(1.1) rotate(-3deg);
            }
        }
        
        /* Context Menu Styles */
        .context-menu {
            position: fixed;
            z-index: 10001;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            padding: 8px 0;
            display: none;
            min-width: 200px;
            direction: rtl;
            font-family: 'Segoe UI', Arial, sans-serif;
        }
        
        .context-menu-item {
            display: flex;
            align-items: center;
            padding: 10px 16px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            gap: 10px;
        }
        
        .context-menu-item:hover {
            background-color: #f8fafc;
        }
        
        .context-menu-item:active {
            background-color: #e2e8f0;
        }
        
        .context-menu-icon {
            font-size: 16px;
            width: 20px;
            text-align: center;
            flex-shrink: 0;
        }
        
        .context-menu-text {
            flex: 1;
            font-size: 14px;
            color: #374151;
        }
        
        .context-menu-divider {
            height: 1px;
            background: #e2e8f0;
            margin: 4px 0;
        }
        
        .context-menu-item[data-action="remove"] {
            color: #dc2626;
        }
        
        .context-menu-item[data-action="remove"]:hover {
            background-color: #fef2f2;
        }
        
        .day-slot.context-target {
            border-color: #3b82f6 !important;
            border-width: 2px !important;
            box-shadow: 0 0 8px rgba(59, 130, 246, 0.3);
        }
        
        /* Conflict Dialog Styles */
        .conflict-dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10002;
            display: none;
            justify-content: center;
            align-items: center;
        }
        
        .conflict-dialog {
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.25);
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            direction: rtl;
            font-family: 'Segoe UI', Arial, sans-serif;
        }
        
        .conflict-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 24px 16px;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .conflict-header h3 {
            margin: 0;
            color: #dc2626;
            font-size: 18px;
        }
        
        .conflict-close-btn {
            background: none;
            border: none;
            font-size: 24px;
            color: #6b7280;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .conflict-close-btn:hover {
            color: #374151;
        }
        
        .conflict-content {
            padding: 20px 24px;
        }
        
        .conflict-info p {
            margin: 8px 0;
            color: #374151;
        }
        
        .conflict-reasons {
            margin-top: 16px;
            padding: 12px;
            background: #fef2f2;
            border-radius: 8px;
            border-right: 3px solid #dc2626;
        }
        
        .conflict-reasons ul {
            margin: 8px 0 0 20px;
            color: #7f1d1d;
        }
        
        .conflict-options {
            margin-top: 20px;
        }
        
        .conflict-option {
            display: flex;
            align-items: center;
            margin: 12px 0;
            gap: 10px;
        }
        
        .conflict-option input[type="radio"] {
            margin: 0;
        }
        
        .conflict-option label {
            cursor: pointer;
            color: #374151;
            margin: 0;
        }
        
        .conflict-actions {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            padding: 16px 24px 20px;
            border-top: 1px solid #e2e8f0;
        }
        
        .conflict-actions .btn {
            padding: 8px 16px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
        }
        
        .conflict-actions .btn-primary {
            background: #3b82f6;
            color: white;
        }
        
        .conflict-actions .btn-primary:hover {
            background: #2563eb;
        }
        
        .conflict-actions .btn-secondary {
            background: #f3f4f6;
            color: #374151;
        }
        
        .conflict-actions .btn-secondary:hover {
            background: #e5e7eb;
        }
        
        /* Bulk Operations Panel Styles */
        .bulk-panel {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            margin: 16px 0;
            padding: 0;
            direction: rtl;
        }
        
        .bulk-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            background: #3b82f6;
            color: white;
            border-radius: 8px 8px 0 0;
        }
        
        .bulk-header h3 {
            margin: 0;
            font-size: 16px;
        }
        
        .bulk-close {
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
        }
        
        .bulk-close:hover {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
        }
        
        .bulk-actions {
            display: flex;
            gap: 12px;
            padding: 16px 20px;
            flex-wrap: wrap;
        }
        
        .bulk-action-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            background: white;
            color: #374151;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }
        
        .bulk-action-btn:hover:not(:disabled) {
            background: #f3f4f6;
            border-color: #9ca3af;
        }
        
        .bulk-action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .bulk-action-btn.primary {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }
        
        .bulk-action-btn.primary:hover:not(:disabled) {
            background: #2563eb;
        }
        
        .bulk-action-btn.secondary {
            background: #6b7280;
            color: white;
            border-color: #6b7280;
        }
        
        .bulk-action-btn.secondary:hover:not(:disabled) {
            background: #4b5563;
        }
        
        .bulk-guide-selector {
            padding: 16px 20px;
            border-top: 1px solid #e2e8f0;
            background: white;
        }
        
        .bulk-guide-selector label {
            display: block;
            margin-bottom: 8px;
            color: #374151;
            font-weight: 500;
        }
        
        .bulk-guide-selector select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            margin-bottom: 16px;
            direction: rtl;
        }
        
        .bulk-slot-options {
            display: flex;
            gap: 16px;
            margin-bottom: 16px;
        }
        
        .bulk-slot-options label {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 0;
            font-weight: normal;
        }
        
        .calendar-day.bulk-selected {
            background: #dbeafe !important;
            border: 2px solid #3b82f6 !important;
            box-shadow: 0 0 8px rgba(59, 130, 246, 0.3);
        }
        
        .calendar-day.bulk-selected .day-number {
            color: #1d4ed8;
            font-weight: bold;
        }
        
        /* Statistics Panel Styles */
        .statistics-panel {
            background: linear-gradient(135deg, #f8fafc, #e2e8f0);
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            margin: 16px 0;
            padding: 16px;
            direction: rtl;
        }
        
        .stats-header h3 {
            margin: 0 0 12px 0;
            color: #1e40af;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .stats-summary {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            font-size: 14px;
        }
        
        .stats-summary span {
            color: #475569;
        }
        
        .stats-summary strong {
            color: #1e293b;
        }
        
        .fairness-indicator strong {
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .fairness-good {
            background: #dcfce7;
            color: #166534;
        }
        
        .fairness-warning {
            background: #fef3c7;
            color: #92400e;
        }
        
        .fairness-poor {
            background: #fecaca;
            color: #991b1b;
        }
        
        .export-stats-btn {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 4px 12px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            margin-right: auto;
        }
        
        .export-stats-btn:hover {
            background: #2563eb;
            transform: translateY(-1px);
        }
        
        .export-stats-btn:active {
            transform: translateY(0);
        }
        
        /* Guide Card Fairness Indicators */
        .guide-card.overworked {
            border-left: 4px solid #dc2626;
            background: linear-gradient(to right, #fef2f2, white);
        }
        
        .guide-card.underworked {
            border-left: 4px solid #2563eb;
            background: linear-gradient(to right, #eff6ff, white);
        }
        
        .guide-card.balanced {
            border-left: 4px solid #059669;
            background: linear-gradient(to right, #ecfdf5, white);
        }
        
        /* Context Menu Styling */
        .context-menu {
            position: fixed;
            z-index: 10001;
            background: white;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            padding: 8px 0;
            min-width: 180px;
            display: none;
            direction: rtl;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .context-menu-item {
            display: flex;
            align-items: center;
            padding: 8px 16px;
            cursor: pointer;
            transition: background-color 0.2s;
            gap: 8px;
            font-size: 14px;
            color: #374151;
        }
        
        .context-menu-item:hover {
            background-color: #f3f4f6;
        }
        
        .context-menu-item:active {
            background-color: #e5e7eb;
        }
        
        .context-menu-icon {
            width: 20px;
            text-align: center;
            font-size: 14px;
        }
        
        .context-menu-separator {
            height: 1px;
            background-color: #e5e7eb;
            margin: 4px 0;
        }
        
        .context-menu-item[data-action="remove"]:hover {
            background-color: #fef2f2;
            color: #dc2626;
        }
        
        .context-menu-item[data-action="assign-normal"],
        .context-menu-item[data-action="assign-overlap"] {
            color: #059669;
        }
        
        .context-menu-item[data-action="assign-normal"]:hover,
        .context-menu-item[data-action="assign-overlap"]:hover {
            background-color: #ecfdf5;
        }
        
        /* Enhanced Loading States */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10002;
            backdrop-filter: blur(2px);
        }
        
        .loading-spinner {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            text-align: center;
            min-width: 200px;
            direction: rtl;
        }
        
        .spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #8b5cf6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading-text {
            color: #4b5563;
            font-weight: 500;
            font-size: 14px;
        }
        
        .loading-progress {
            width: 100%;
            height: 4px;
            background: #e5e7eb;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 15px;
        }
        
        .loading-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #8b5cf6, #a855f7);
            border-radius: 2px;
            transition: width 0.3s ease;
        }
        
        /* Inline loading indicators */
        .inline-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #8b5cf6;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-left: 8px;
            vertical-align: middle;
        }
        
        /* Button loading states */
        .btn-loading {
            position: relative;
            color: transparent !important;
            pointer-events: none;
        }
        
        .btn-loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 16px;
            height: 16px;
            margin: -8px 0 0 -8px;
            border: 2px solid transparent;
            border-top-color: #ffffff;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        
        /* Progressive loading states */
        .loading-skeleton {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: loading 1.5s infinite;
            border-radius: 4px;
        }
        
        @keyframes loading {
            0% {
                background-position: 200% 0;
            }
            100% {
                background-position: -200% 0;
            }
        }
        
        .guide-card .workload-indicator {
            font-size: 11px;
            padding: 2px 4px;
            border-radius: 3px;
            margin-top: 2px;
        }
        
        .guide-card.overworked .workload-indicator {
            background: #fee2e2;
            color: #991b1b;
        }
        
        .guide-card.underworked .workload-indicator {
            background: #dbeafe;
            color: #1d4ed8;
        }
        
        .guide-card.balanced .workload-indicator {
            background: #d1fae5;
            color: #065f46;
        }

        /* Notifications */
        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border-radius: 8px;
            padding: 15px 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            z-index: 10000;
            border-left: 4px solid #10b981;
            display: none;
        }

        .notification.error {
            border-left-color: #ef4444;
        }

        .notification.warning {
            border-left-color: #f59e0b;
        }

        .notification.show {
            display: block;
            animation: slideDown 0.3s ease-out;
        }

        @keyframes slideDown {
            from { transform: translateX(-50%) translateY(-20px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }
        
        /* Confirmation Dialog Styles */
        .confirmation-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10003;
            backdrop-filter: blur(3px);
        }
        
        .confirmation-dialog {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
            max-width: 450px;
            min-width: 350px;
            text-align: center;
            direction: rtl;
            animation: dialogSlideUp 0.3s ease-out;
        }
        
        @keyframes dialogSlideUp {
            from {
                opacity: 0;
                transform: translateY(30px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        .confirmation-icon {
            font-size: 48px;
            margin-bottom: 20px;
            display: block;
        }
        
        .confirmation-icon.warning {
            color: #f59e0b;
        }
        
        .confirmation-icon.danger {
            color: #ef4444;
        }
        
        .confirmation-icon.info {
            color: #3b82f6;
        }
        
        .confirmation-title {
            font-size: 20px;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 15px;
            line-height: 1.4;
        }
        
        .confirmation-message {
            font-size: 14px;
            color: #6b7280;
            margin-bottom: 25px;
            line-height: 1.5;
        }
        
        .confirmation-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
        }
        
        .confirmation-button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-weight: 500;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 100px;
        }
        
        .confirmation-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        
        .confirmation-button.primary {
            background: #8b5cf6;
            color: white;
        }
        
        .confirmation-button.primary:hover {
            background: #7c3aed;
        }
        
        .confirmation-button.danger {
            background: #ef4444;
            color: white;
        }
        
        .confirmation-button.danger:hover {
            background: #dc2626;
        }
        
        .confirmation-button.secondary {
            background: #f3f4f6;
            color: #6b7280;
            border: 1px solid #d1d5db;
        }
        
        .confirmation-button.secondary:hover {
            background: #e5e7eb;
            color: #374151;
        }
        
        .confirmation-details {
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 12px;
            margin: 15px 0;
            font-size: 13px;
            color: #4b5563;
            text-align: right;
            line-height: 1.4;
        }
        
        /* Enhanced Notification Animations */
        @keyframes notificationSlideIn {
            from {
                opacity: 0;
                transform: translateY(-20px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        @keyframes notificationSlideOut {
            from {
                opacity: 1;
                transform: translateY(0) scale(1);
                max-height: 200px;
            }
            to {
                opacity: 0;
                transform: translateY(-20px) scale(0.95);
                max-height: 0;
                margin-bottom: 0;
                padding-top: 0;
                padding-bottom: 0;
            }
        }
        
        /* Notification container styles */
        .enhanced-notification {
            position: relative;
            overflow: hidden;
        }
        
        .enhanced-notification::before {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(0,0,0,0.1));
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .enhanced-notification:hover::before {
            opacity: 1;
        }
        
        .enhanced-notification button:hover {
            color: #374151 !important;
            transform: scale(1.1);
        }
        
        /* Notification type-specific styles */
        .enhanced-notification.success {
            border-right-color: #10b981;
        }
        
        .enhanced-notification.error {
            border-right-color: #ef4444;
        }
        
        .enhanced-notification.warning {
            border-right-color: #f59e0b;
        }
        
        .enhanced-notification.info {
            border-right-color: #3b82f6;
        }
        
        .enhanced-notification.loading {
            border-right-color: #8b5cf6;
        }
        
        /* Progress notification specific styles */
        .progress-notification {
            min-width: 300px;
        }
        
        .progress-bar {
            background: #e5e7eb;
            border-radius: 2px;
            height: 4px;
            margin-top: 8px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #8b5cf6, #a855f7);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        /* Enhanced Tooltip System */
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            white-space: nowrap;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            direction: rtl;
            text-align: center;
        }

        .tooltip.show {
            opacity: 1;
        }

        .tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border: 5px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.9);
        }

        .tooltip.bottom::after {
            top: -10px;
            border-top-color: transparent;
            border-bottom-color: rgba(0, 0, 0, 0.9);
        }

        /* Interactive Guide System */
        .help-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .help-step {
            position: absolute;
            background: white;
            border-radius: 8px;
            padding: 20px;
            max-width: 300px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            direction: rtl;
            animation: slideInUp 0.4s ease;
        }

        .help-step h4 {
            margin: 0 0 10px 0;
            color: #7c3aed;
            font-size: 1.1rem;
        }

        .help-step p {
            margin: 0 0 15px 0;
            color: #4b5563;
            line-height: 1.5;
        }

        .help-step-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        .help-step-nav {
            display: flex;
            gap: 8px;
        }

        .help-step-nav button {
            background: #7c3aed;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .help-step-nav button:hover {
            background: #6d28d9;
        }

        .help-step-nav button:disabled {
            background: #d1d5db;
            cursor: not-allowed;
        }

        .help-step-indicator {
            font-size: 0.8rem;
            color: #6b7280;
        }

        /* Contextual Help Buttons */
        .help-hint {
            position: relative;
            display: inline-block;
            background: #3b82f6;
            color: white;
            border: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-right: 5px;
        }

        .help-hint:hover {
            background: #2563eb;
            transform: scale(1.1);
        }

        .guide-tutorial-highlight {
            position: relative;
            z-index: 9999;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.7);
            border-radius: 8px;
        }

        /* Detailed Help Modal */
        .detailed-help-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10001;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s ease;
        }

        .help-modal-content {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 800px;
            max-height: 90%;
            overflow: hidden;
            direction: rtl;
            animation: slideInUp 0.4s ease;
        }

        .help-modal-header {
            background: #7c3aed;
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .help-modal-header h2 {
            margin: 0;
            font-size: 1.5rem;
        }

        .help-modal-close {
            background: none;
            border: none;
            color: white;
            font-size: 30px;
            cursor: pointer;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            transition: background 0.2s ease;
        }

        .help-modal-close:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .help-modal-body {
            padding: 0;
            max-height: calc(90vh - 80px);
            overflow-y: auto;
        }

        .help-sections {
            padding: 20px;
        }

        .help-section {
            margin-bottom: 30px;
            padding: 20px;
            background: #f8fafc;
            border-radius: 8px;
            border-right: 4px solid #7c3aed;
        }

        .help-section h3 {
            color: #7c3aed;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .help-section ul, .help-section ol {
            margin: 0;
            padding-right: 20px;
        }

        .help-section li {
            margin-bottom: 8px;
            line-height: 1.6;
        }

        .help-section strong {
            color: #374151;
        }

        /* Accessibility - Screen Reader Only */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Focus styles for better accessibility */
        .guide-card:focus,
        button:focus,
        .day-slot:focus {
            outline: 2px solid #7c3aed;
            outline-offset: 2px;
        }

        .guide-card:focus {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 6px 20px rgba(124, 58, 237, 0.3);
        }

        /* High contrast mode support */
        @media (prefers-contrast: high) {
            .guide-card,
            .calendar-day,
            .action-button {
                border-width: 2px;
                border-style: solid;
            }
        }

        /* Reduced motion support */
        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
    </style>
</head>

<body>
    <!-- Include common header -->
    <div id="header-placeholder"></div>

    <div class="main-container">

        <!-- Main Content -->
        <div class="content-wrapper">
            <!-- Month Navigation -->
            <div class="month-navigation">
                <div class="month-controls">
                    <button class="month-button" id="prev-month-btn">חודש קודם</button>
                    <div class="current-month-display" id="current-month-display">
                        טוען...
                    </div>
                    <button class="month-button" id="next-month-btn">חודש הבא</button>
                </div>
                <div class="month-info">
                    <div class="status-item">
                        <span class="status-icon">📅</span>
                        <span id="month-stats">טוען נתונים...</span>
                    </div>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="action-buttons">
                <button class="action-button" id="save-changes-btn" aria-label="שמור שינויים לשיבוץ החודשי" aria-describedby="save-status">
                    <span aria-hidden="true">💾</span>
                    שמור שינויים
                </button>
                <button class="action-button secondary" id="clear-selection-btn" aria-label="נקה בחירה נוכחית של מדריך">
                    <span aria-hidden="true">🔄</span>
                    נקה בחירה
                </button>
                <button class="action-button secondary" id="undo-btn" disabled aria-label="בטל פעולה אחרונה" aria-describedby="undo-status">
                    <span aria-hidden="true">↩️</span>
                    בטל פעולה
                </button>
                <button class="action-button secondary" id="redo-btn" disabled aria-label="חזור על פעולה שבוטלה" aria-describedby="redo-status">
                    <span aria-hidden="true">↪️</span>
                    חזור על פעולה
                </button>
                <button class="action-button danger" id="clear-month-btn" aria-label="נקה את כל השיבוצים של החודש">
                    <span aria-hidden="true">🗑️</span>
                    נקה חודש
                </button>
                <button class="action-button secondary" id="import-schedule-btn" aria-label="ייבא שיבוץ קיים מהמערכת הרגילה">
                    <span aria-hidden="true">📥</span>
                    ייבא שיבוץ
                </button>
                <button class="action-button secondary" id="bulk-mode-btn" aria-label="כניסה למצב בחירה מרובה לשיבוץ מספר תאריכים">
                    <span aria-hidden="true">📋</span>
                    מצב בחירה מרובה
                </button>
                <div style="margin-right: auto;">
                    <button class="action-button secondary" id="help-btn" aria-label="התחל סיור מודרך למערכת השיבוץ" onclick="tutorialSystem.startTutorial()">
                        <span aria-hidden="true">❓</span>
                        סיור מודרך
                    </button>
                    <button class="action-button secondary" id="detailed-help-btn" aria-label="פתח מדריך מפורט למערכת השיבוץ" onclick="showDetailedHelp()">
                        <span aria-hidden="true">📖</span>
                        מדריך מפורט
                    </button>
                    <button class="action-button secondary" id="refresh-btn" aria-label="רענן נתונים - טען מחדש את נתוני המדריכים והשיבוצים">
                        <span aria-hidden="true">🔄</span>
                        רענן
                    </button>
                </div>
            </div>

            <!-- Bulk Operations Panel -->
            <div id="bulk-operations-panel" class="bulk-panel" style="display: none;">
                <div class="bulk-header">
                    <h3>פעולות על בחירה מרובה</h3>
                    <span id="selected-count">0 תאריכים נבחרו</span>
                    <button id="bulk-close-btn" class="bulk-close">×</button>
                </div>
                <div class="bulk-actions">
                    <button class="bulk-action-btn" id="bulk-assign-btn" disabled>
                        <span>👤</span>
                        שבץ מדריך לכל התאריכים
                    </button>
                    <button class="bulk-action-btn" id="bulk-clear-btn" disabled>
                        <span>🗑️</span>
                        נקה שיבוצים מהתאריכים
                    </button>
                    <button class="bulk-action-btn" id="bulk-copy-pattern-btn" disabled>
                        <span>📋</span>
                        העתק דפוס שיבוץ
                    </button>
                    <button class="bulk-action-btn" id="bulk-apply-constraints-btn" disabled>
                        <span>⚠️</span>
                        החל אילוצים
                    </button>
                </div>
                <div class="bulk-guide-selector" id="bulk-guide-selector" style="display: none;">
                    <label>בחר מדריך לשיבוץ מרובה:</label>
                    <select id="bulk-guide-select">
                        <option value="">-- בחר מדריך --</option>
                    </select>
                    <div class="bulk-slot-options">
                        <label>
                            <input type="checkbox" id="bulk-normal-slot" checked> משמרת רגילה
                        </label>
                        <label>
                            <input type="checkbox" id="bulk-overlap-slot"> משמרת חפיפה
                        </label>
                    </div>
                    <button class="bulk-action-btn primary" id="bulk-confirm-assign">אשר שיבוץ</button>
                    <button class="bulk-action-btn secondary" id="bulk-cancel-assign">בטל</button>
                </div>
            </div>

            <!-- Statistics Panel -->
            <div class="statistics-panel" id="statistics-panel">
                <div class="stats-header">
                    <h3>📊 סטטיסטיקות חודשיות</h3>
                    <div class="stats-summary">
                        <span>סה״כ משמרות: <strong id="total-shifts-count">0</strong></span>
                        <span>ממוצע: <strong id="average-shifts-count">0</strong></span>
                        <span class="fairness-indicator">מאזן: <strong id="fairness-status">טוב</strong></span>
                        <span>עלות: <strong id="total-salary-factor">0</strong></span>
                        <button class="export-stats-btn" onclick="exportMonthlyStatistics()" title="ייצא סטטיסטיקות לקובץ CSV">
                            📊 ייצוא
                        </button>
                    </div>
                </div>
            </div>

            <!-- Guides Section -->
            <div class="guides-section">
                <div class="guides-header">
                    <h2 class="guides-title" id="guides-section-title" role="heading" aria-level="2">
                        מדריכים זמינים
                        <button class="help-hint" title="גרור מדריך לתאריך כדי לשבץ אותו. לחץ על מדריך לצפייה באילוצים" aria-label="עזרה על מדריכים זמינים">?</button>
                    </h2>
                    <div class="guides-info" id="guides-info" aria-live="polite" aria-atomic="true">
                        טוען מדריכים...
                    </div>
                </div>
                <div class="guides-container" id="guides-container" role="list" aria-labelledby="guides-section-title" aria-describedby="guides-info">
                    <!-- Guide cards will be populated by JavaScript -->
                    <div class="loading active" role="status" aria-label="טוען מדריכים">
                        <div class="loading-spinner"></div>
                        טוען מדריכים...
                    </div>
                </div>
            </div>

            <!-- Status Bar -->
            <div class="status-bar">
                <div class="status-info">
                    <div class="status-item">
                        <span class="status-icon">👤</span>
                        <span id="selected-guide-info">לא נבחר מדריך</span>
                    </div>
                    <div class="status-item">
                        <span class="status-icon">🚫</span>
                        <span id="constraints-count">0 אילוצים</span>
                    </div>
                    <div class="status-item">
                        <span class="status-icon">📊</span>
                        <span id="assignments-count">0 שיבוצים</span>
                    </div>
                </div>
                <div class="status-item">
                    <span class="status-icon">⏱️</span>
                    <span id="last-updated">טוען...</span>
                </div>
            </div>

            <!-- Calendar Section -->
            <div class="calendar-section">
                <div class="calendar-header">
                    <h2 class="calendar-title" id="calendar-section-title" role="heading" aria-level="2">
                        לוח שיבוץ חודשי
                        <button class="help-hint" title="גרור מדריכים לתאריכים כדי לשבץ. לחץ ימין על תאריך לפעולות נוספות" aria-label="עזרה על לוח השיבוץ">?</button>
                    </h2>
                    <div class="calendar-legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #8b5cf6;"></div>
                            <span>משמרת רגילה</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #f59e0b;"></div>
                            <span>חפיפה</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #10b981;"></div>
                            <span>זמין לשיבוץ</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #d97706;"></div>
                            <span>חגים יהודיים</span>
                        </div>
                    </div>
                    
                    <!-- Enhanced Constraint Legend -->
                    <div class="constraint-legend">
                        <div class="legend-constraint-item">
                            <div class="legend-constraint-icon regular">🚫</div>
                            <span>אילוץ רגיל</span>
                        </div>
                        <div class="legend-constraint-item">
                            <div class="legend-constraint-icon fixed">📅</div>
                            <span>אילוץ קבוע</span>
                        </div>
                        <div class="legend-constraint-item">
                            <div class="legend-constraint-icon vacation">🌴</div>
                            <span>חופשה</span>
                        </div>
                        <div class="legend-constraint-item">
                            <div class="legend-constraint-icon dynamic">⚠️</div>
                            <span>אילוץ דינמי</span>
                        </div>
                    </div>
                </div>
                
                <div class="calendar-grid" id="calendar-grid" role="grid" aria-labelledby="calendar-section-title" aria-describedby="calendar-legend">
                    <!-- Calendar will be populated by JavaScript -->
                    <div class="loading active" style="grid-column: 1 / -1; padding: 40px;" role="status" aria-label="טוען לוח שיבוץ">
                        <div class="loading-spinner"></div>
                        טוען לוח שיבוץ...
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Include common footer -->
    <div id="footer-placeholder"></div>

    <!-- Notification Toast -->
    <div class="notification" id="notification">
        <div id="notification-message"></div>
    </div>

    <!-- JavaScript -->
    <script>
        // Enhanced Manual Scheduler JavaScript
        console.log('🖱️ Enhanced Manual Scheduler Loading...');
        
        // Global state
        let currentYear = new Date().getFullYear();
        let currentMonth = new Date().getMonth() + 1;
        let selectedGuide = null;
        let guides = [];
        let constraints = {};
        let assignments = [];
        let undoStack = [];
        let redoStack = [];
        let copiedAssignment = null;
        const MAX_UNDO_HISTORY = 50;
        let bulkSelectionMode = false;
        let selectedDates = new Set();
        let bulkOperationInProgress = false;
        
        // Context menu functionality
        let contextMenuElement = null;
        let contextMenuTarget = null;
        
        function createContextMenu() {
            if (contextMenuElement) return contextMenuElement;
            
            contextMenuElement = document.createElement('div');
            contextMenuElement.className = 'context-menu';
            contextMenuElement.id = 'context-menu';
            contextMenuElement.innerHTML = `
                <div class="context-menu-item" data-action="assign-normal">
                    <span class="context-menu-icon">👤</span>
                    <span>שיבוץ רגיל</span>
                </div>
                <div class="context-menu-item" data-action="assign-overlap">
                    <span class="context-menu-icon">👥</span>
                    <span>שיבוץ חפיפה</span>
                </div>
                <div class="context-menu-separator"></div>
                <div class="context-menu-item" data-action="remove">
                    <span class="context-menu-icon">🗑️</span>
                    <span>הסר שיבוץ</span>
                </div>
                <div class="context-menu-item" data-action="swap">
                    <span class="context-menu-icon">🔄</span>
                    <span>החלף מדריך</span>
                </div>
                <div class="context-menu-separator"></div>
                <div class="context-menu-item" data-action="details">
                    <span class="context-menu-icon">ℹ️</span>
                    <span>פרטי שיבוץ</span>
                </div>
                <div class="context-menu-item" data-action="copy">
                    <span class="context-menu-icon">📋</span>
                    <span>העתק</span>
                </div>
                <div class="context-menu-item" data-action="paste">
                    <span class="context-menu-icon">📂</span>
                    <span>הדבק</span>
                </div>
            `;
            
            // Add event listeners
            contextMenuElement.addEventListener('click', handleContextMenuClick);
            document.body.appendChild(contextMenuElement);
            
            return contextMenuElement;
        }
        
        function handleContextMenu(e) {
            // Find if we're right-clicking on a calendar slot
            const slot = e.target.closest('.day-slot');
            if (!slot) {
                hideContextMenu();
                return;
            }
            
            e.preventDefault();
            contextMenuTarget = slot;
            
            const menu = createContextMenu();
            
            // Position the context menu
            let x = e.clientX;
            let y = e.clientY;
            
            // Ensure menu doesn't go off screen
            if (x + 200 > window.innerWidth) x = window.innerWidth - 200;
            if (y + 300 > window.innerHeight) y = window.innerHeight - 300;
            
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.style.display = 'block';
            
            updateContextMenuItems(slot);
        }
        
        function updateContextMenuItems(slot) {
            if (!contextMenuElement) return;
            
            const isOccupied = slot.classList.contains('occupied');
            const hasConstraints = slot.classList.contains('constraint-blocked');
            const slotType = slot.dataset.slot;
            
            const items = contextMenuElement.querySelectorAll('.context-menu-item');
            
            items.forEach(item => {
                const action = item.dataset.action;
                
                switch(action) {
                    case 'assign-normal':
                    case 'assign-overlap':
                        item.style.display = (isOccupied || hasConstraints || !selectedGuide) ? 'none' : 'flex';
                        break;
                    case 'remove':
                    case 'swap':
                    case 'details':
                    case 'copy':
                        item.style.display = isOccupied ? 'flex' : 'none';
                        break;
                    case 'paste':
                        item.style.display = (copiedAssignment && !isOccupied) ? 'flex' : 'none';
                        break;
                }
            });
        }
        
        function handleContextMenuClick(e) {
            e.preventDefault();
            const action = e.target.closest('.context-menu-item')?.dataset.action;
            if (!action || !contextMenuTarget) return;
            
            const date = contextMenuTarget.dataset.date;
            const slotType = contextMenuTarget.dataset.slot;
            
            switch(action) {
                case 'assign-normal':
                    if (selectedGuide) createAssignmentFromContext(selectedGuide.id, date, 'normal');
                    break;
                case 'assign-overlap':
                    if (selectedGuide) createAssignmentFromContext(selectedGuide.id, date, 'overlap');
                    break;
                case 'remove':
                    removeAssignmentFromSlot(date, slotType);
                    break;
                case 'swap':
                    if (selectedGuide) swapAssignment(date, slotType, selectedGuide.id);
                    break;
                case 'details':
                    showAssignmentDetails(date, slotType);
                    break;
                case 'copy':
                    copyAssignment(date, slotType);
                    break;
                case 'paste':
                    pasteAssignment(date, slotType);
                    break;
            }
            
            hideContextMenu();
        }
        
        function hideContextMenu() {
            if (contextMenuElement) {
                contextMenuElement.style.display = 'none';
                contextMenuTarget = null;
            }
        }
        
        async function createAssignmentFromContext(guideId, date, slotType) {
            try {
                showNotification('יוצר שיבוץ...', 'info');
                await createAssignment(guideId, date, slotType);
                showNotification('שיבוץ נוצר בהצלחה', 'success');
            } catch (error) {
                console.error('Error creating assignment from context:', error);
                showNotification('שגיאה ביצירת שיבוץ', 'error');
            }
        }
        
        function copyAssignment(date, slotType) {
            const slot = document.querySelector(`[data-date="${date}"][data-slot="${slotType}"]`);
            if (!slot || !slot.classList.contains('occupied')) return;
            
            const assignmentDisplay = slot.querySelector('.assignment-display');
            if (assignmentDisplay) {
                const guideName = assignmentDisplay.querySelector('.assigned-guide-name')?.textContent;
                copiedAssignment = { guideName, slotType, originalDate: date };
                showNotification(`הועתק: ${guideName}`, 'success');
            }
        }
        
        async function pasteAssignment(date, slotType) {
            if (!copiedAssignment || !selectedGuide) return;
            
            try {
                showNotification('מדביק שיבוץ...', 'info');
                await createAssignment(selectedGuide.id, date, slotType);
                showNotification(`הודבק שיבוץ ל-${date}`, 'success');
            } catch (error) {
                console.error('Error pasting assignment:', error);
                showNotification('שגיאה בהדבקת שיבוץ', 'error');
            }
        }
        
        async function swapAssignment(date, slotType, newGuideId) {
            try {
                // Get current guide name for confirmation
                const slot = document.querySelector(`[data-date="${date}"][data-slot="${slotType}"]`);
                const originalGuide = slot?.querySelector('.assigned-guide-name')?.textContent || 'מדריך לא ידוע';
                const newGuide = guides.find(g => g.id === newGuideId)?.name || 'מדריך לא ידוע';
                
                const confirmed = await confirmSwapAssignment(originalGuide, newGuide, date);
                if (!confirmed) {
                    showNotification('החלפת המדריך בוטלה', 'info');
                    return;
                }
                
                showNotification('מחליף מדריך...', 'info');
                await removeAssignmentFromSlot(date, slotType, true); // Skip confirmation for internal call
                await createAssignment(newGuideId, date, slotType);
                showNotification('מדריך הוחלף בהצלחה', 'success');
            } catch (error) {
                console.error('Error swapping assignment:', error);
                showNotification('שגיאה בהחלפת מדריך', 'error');
            }
        }
        
        function showAssignmentDetails(date, slotType) {
            const slot = document.querySelector(`[data-date="${date}"][data-slot="${slotType}"]`);
            if (!slot || !slot.classList.contains('occupied')) return;
            
            const assignmentDisplay = slot.querySelector('.assignment-display');
            if (assignmentDisplay) {
                const guideName = assignmentDisplay.querySelector('.assigned-guide-name')?.textContent;
                const details = `📋 פרטי שיבוץ:\n👤 מדריך: ${guideName}\n📅 תאריך: ${new Date(date).toLocaleDateString('he-IL')}\n⏰ סוג: ${slotType === 'normal' ? 'רגיל' : 'חפיפה'}`;
                showNotification(details, 'info', 6000);
            }
        }
        
        // Enhanced Loading States Functions
        let loadingOverlay = null;
        let currentProgress = 0;
        
        function showGlobalLoading(message = 'טוען...', showProgress = false) {
            hideGlobalLoading(); // Remove any existing overlay
            
            loadingOverlay = document.createElement('div');
            loadingOverlay.className = 'loading-overlay';
            loadingOverlay.innerHTML = `
                <div class="loading-spinner">
                    <div class="spinner"></div>
                    <div class="loading-text">${message}</div>
                    ${showProgress ? `
                        <div class="loading-progress">
                            <div class="loading-progress-bar" style="width: ${currentProgress}%"></div>
                        </div>
                    ` : ''}
                </div>
            `;
            
            document.body.appendChild(loadingOverlay);
            
            // Prevent scrolling while loading
            document.body.style.overflow = 'hidden';
        }
        
        function updateLoadingProgress(progress, message = null) {
            if (!loadingOverlay) return;
            
            currentProgress = Math.min(100, Math.max(0, progress));
            
            const progressBar = loadingOverlay.querySelector('.loading-progress-bar');
            if (progressBar) {
                progressBar.style.width = currentProgress + '%';
            }
            
            if (message) {
                const loadingText = loadingOverlay.querySelector('.loading-text');
                if (loadingText) {
                    loadingText.textContent = message;
                }
            }
        }
        
        function hideGlobalLoading() {
            if (loadingOverlay) {
                document.body.removeChild(loadingOverlay);
                loadingOverlay = null;
                currentProgress = 0;
                
                // Restore scrolling
                document.body.style.overflow = '';
            }
        }
        
        function showButtonLoading(buttonElement) {
            if (!buttonElement) return;
            
            buttonElement.classList.add('btn-loading');
            buttonElement.disabled = true;
            
            // Store original text
            if (!buttonElement.dataset.originalText) {
                buttonElement.dataset.originalText = buttonElement.textContent;
            }
        }
        
        function hideButtonLoading(buttonElement) {
            if (!buttonElement) return;
            
            buttonElement.classList.remove('btn-loading');
            buttonElement.disabled = false;
            
            // Restore original text
            if (buttonElement.dataset.originalText) {
                buttonElement.textContent = buttonElement.dataset.originalText;
            }
        }
        
        function showInlineLoading(element) {
            if (!element) return;
            
            const spinner = document.createElement('span');
            spinner.className = 'inline-spinner';
            spinner.setAttribute('data-loading-indicator', 'true');
            
            element.appendChild(spinner);
        }
        
        function hideInlineLoading(element) {
            if (!element) return;
            
            const spinners = element.querySelectorAll('[data-loading-indicator]');
            spinners.forEach(spinner => spinner.remove());
        }
        
        function showSkeletonLoading(element, height = '20px') {
            if (!element) return;
            
            element.innerHTML = `<div class="loading-skeleton" style="height: ${height}; width: 100%;"></div>`;
        }
        
        // Enhanced loading for specific operations
        async function withLoadingState(operation, loadingMessage = 'מעבד...', buttonElement = null) {
            try {
                if (buttonElement) {
                    showButtonLoading(buttonElement);
                } else {
                    showGlobalLoading(loadingMessage);
                }
                
                const result = await operation();
                return result;
                
            } catch (error) {
                console.error('Operation failed:', error);
                throw error;
            } finally {
                if (buttonElement) {
                    hideButtonLoading(buttonElement);
                } else {
                    hideGlobalLoading();
                }
            }
        }
        
        // Confirmation Dialog Functions
        function showConfirmationDialog({
            title = 'אישור פעולה',
            message = 'האם אתה בטוח שברצונך לבצע פעולה זו?',
            icon = 'warning', // warning, danger, info
            confirmText = 'אישור',
            cancelText = 'ביטול',
            confirmStyle = 'primary', // primary, danger
            details = null,
            onConfirm = () => {},
            onCancel = () => {}
        }) {
            return new Promise((resolve) => {
                // Remove any existing dialog
                const existingDialog = document.querySelector('.confirmation-overlay');
                if (existingDialog) {
                    existingDialog.remove();
                }
                
                // Create dialog overlay
                const overlay = document.createElement('div');
                overlay.className = 'confirmation-overlay';
                
                // Create dialog content
                const dialog = document.createElement('div');
                dialog.className = 'confirmation-dialog';
                
                const iconEmojis = {
                    warning: '⚠️',
                    danger: '🗑️',
                    info: 'ℹ️'
                };
                
                dialog.innerHTML = `
                    <span class="confirmation-icon ${icon}">${iconEmojis[icon] || '❓'}</span>
                    <div class="confirmation-title">${title}</div>
                    <div class="confirmation-message">${message}</div>
                    ${details ? `<div class="confirmation-details">${details}</div>` : ''}
                    <div class="confirmation-actions">
                        <button class="confirmation-button secondary" data-action="cancel">${cancelText}</button>
                        <button class="confirmation-button ${confirmStyle}" data-action="confirm">${confirmText}</button>
                    </div>
                `;
                
                overlay.appendChild(dialog);
                document.body.appendChild(overlay);
                
                // Prevent scrolling
                document.body.style.overflow = 'hidden';
                
                // Handle button clicks
                const handleClick = (e) => {
                    const action = e.target.dataset.action;
                    if (action) {
                        cleanup();
                        if (action === 'confirm') {
                            onConfirm();
                            resolve(true);
                        } else {
                            onCancel();
                            resolve(false);
                        }
                    }
                };
                
                // Handle ESC key
                const handleEscape = (e) => {
                    if (e.key === 'Escape') {
                        cleanup();
                        onCancel();
                        resolve(false);
                    }
                };
                
                // Cleanup function
                const cleanup = () => {
                    document.body.style.overflow = '';
                    overlay.remove();
                    document.removeEventListener('keydown', handleEscape);
                };
                
                // Add event listeners
                dialog.addEventListener('click', handleClick);
                document.addEventListener('keydown', handleEscape);
                
                // Focus on confirm button
                setTimeout(() => {
                    const confirmButton = dialog.querySelector('[data-action="confirm"]');
                    if (confirmButton) confirmButton.focus();
                }, 100);
            });
        }
        
        // Confirmation wrappers for destructive operations
        async function confirmRemoveAssignment(date, slotType, guideName) {
            const formattedDate = new Date(date).toLocaleDateString('he-IL');
            const slotText = slotType === 'normal' ? 'רגיל' : 'חפיפה';
            
            return showConfirmationDialog({
                title: 'מחיקת שיבוץ',
                message: 'האם אתה בטוח שברצונך למחוק שיבוץ זה?',
                icon: 'danger',
                confirmText: 'מחק',
                confirmStyle: 'danger',
                details: `מדריך: ${guideName}<br>תאריך: ${formattedDate}<br>סוג: ${slotText}`
            });
        }
        
        async function confirmClearMonth() {
            return showConfirmationDialog({
                title: 'ניקוי חודש',
                message: 'פעולה זו תמחק את כל השיבוצים בחודש הנוכחי.',
                icon: 'danger',
                confirmText: 'נקה הכל',
                confirmStyle: 'danger',
                details: 'לא ניתן לבטל פעולה זו לאחר ביצועה.<br>כל השיבוצים הידניים והאוטומטיים יימחקו.'
            });
        }
        
        async function confirmBulkOperation(operation, selectedCount) {
            const operations = {
                assign: {
                    title: 'שיבוץ מרובה',
                    message: `האם לשבץ את המדריך הנבחר לכל ${selectedCount} התאריכים?`,
                    confirmText: 'שבץ הכל'
                },
                clear: {
                    title: 'מחיקה מרובה',
                    message: `האם למחוק את כל השיבוצים מ-${selectedCount} התאריכים?`,
                    confirmText: 'מחק הכל',
                    confirmStyle: 'danger',
                    icon: 'danger'
                }
            };
            
            const config = operations[operation] || operations.assign;
            
            return showConfirmationDialog({
                title: config.title,
                message: config.message,
                icon: config.icon || 'warning',
                confirmText: config.confirmText,
                confirmStyle: config.confirmStyle || 'primary',
                details: `תאריכים נבחרים: ${selectedCount}`
            });
        }
        
        async function confirmSwapAssignment(originalGuide, newGuide, date) {
            const formattedDate = new Date(date).toLocaleDateString('he-IL');
            
            return showConfirmationDialog({
                title: 'החלפת מדריך',
                message: 'האם אתה בטוח שברצונך להחליף את המדריך?',
                icon: 'info',
                confirmText: 'החלף',
                details: `מדריך נוכחי: ${originalGuide}<br>מדריך חדש: ${newGuide}<br>תאריך: ${formattedDate}`
            });
        }
        
        // Override existing functions to use enhanced loading
        const originalCreateAssignment = createAssignment;
        async function createAssignment(guideId, date, slotType) {
            return withLoadingState(
                () => originalCreateAssignment(guideId, date, slotType),
                'יוצר שיבוץ...'
            );
        }
        
        const originalRemoveAssignmentFromSlot = removeAssignmentFromSlot;
        async function removeAssignmentFromSlot(date, slotType, skipConfirmation = false) {
            if (!skipConfirmation) {
                // Get guide name from slot for confirmation
                const slot = document.querySelector(`[data-date="${date}"][data-slot="${slotType}"]`);
                const guideName = slot?.querySelector('.assigned-guide-name')?.textContent || 'מדריך לא ידוע';
                
                const confirmed = await confirmRemoveAssignment(date, slotType, guideName);
                if (!confirmed) {
                    showNotification('מחיקת השיבוץ בוטלה', 'info');
                    return;
                }
            }
            
            return withLoadingState(
                () => originalRemoveAssignmentFromSlot(date, slotType),
                'מוחק שיבוץ...'
            );
        }

        // Enhanced loading wrappers for more operations
        const originalSaveSchedule = saveSchedule;
        async function saveSchedule() {
            const saveButton = document.querySelector('[data-action="save"]');
            return withLoadingState(
                () => originalSaveSchedule(),
                'שומר שינויים...',
                saveButton
            );
        }
        
        const originalLoadSchedule = loadSchedule;
        async function loadSchedule(year, month) {
            return withLoadingState(
                () => originalLoadSchedule(year, month),
                'טוען לוח שיבוץ...'
            );
        }
        
        const originalRefreshData = refreshData;
        async function refreshData() {
            const refreshButton = document.querySelector('[data-action="refresh"]');
            return withLoadingState(
                () => originalRefreshData(),
                'מרענן נתונים...',
                refreshButton
            );
        }
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('📱 DOM loaded, initializing enhanced manual scheduler...');
            
            // Show initial loading
            showGlobalLoading('מאתחל מערכת שיבוץ...', true);
            
            // Initialize with progress tracking
            setTimeout(() => {
                updateLoadingProgress(20, 'טוען ממשק...');
                setTimeout(() => {
                    updateLoadingProgress(60, 'טוען נתונים...');
                    initializeScheduler().finally(() => {
                        updateLoadingProgress(100, 'הושלם!');
                        setTimeout(hideGlobalLoading, 500);
                    });
                }, 200);
            }, 100);
            
            // Set up context menu listeners
            document.addEventListener('contextmenu', handleContextMenu);
            document.addEventListener('click', hideContextMenu);
        });
        
        // Main initialization function
        // Load header function
        async function loadHeader() {
            try {
                const resp = await fetch('header.html');
                const html = await resp.text();
                const container = document.getElementById('header-placeholder');
                if (container) {
                    container.innerHTML = html;
                    console.log('✅ Header loaded successfully');
                    // After header is loaded, initialize header functions
                    if (typeof renderHeaderUser === 'function') {
                        renderHeaderUser();
                    }
                } else {
                    console.warn('Header placeholder not found');
                }
            } catch (e) {
                console.warn('Failed to load header.html:', e);
            }
        }
        
        async function loadFooter() {
            try {
                const resp = await fetch('footer.html');
                const html = await resp.text();
                const container = document.getElementById('footer-placeholder');
                if (container) {
                    container.innerHTML = html;
                    console.log('✅ Footer loaded successfully');
                } else {
                    console.warn('Footer placeholder not found');
                }
            } catch (e) {
                console.warn('Failed to load footer.html:', e);
            }
        }
        
        async function initializeScheduler() {
            try {
                // Load common header and footer
                await Promise.all([
                    loadHeader(),
                    loadFooter()
                ]);
                
                // Set up event listeners
                setupEventListeners();
                
                // Initialize auto-save functionality
                initAutoSave();
                
                // Initialize offline handling
                initOfflineHandling();
                
                // Load initial data
                await loadMonthData();
                
                console.log('✅ Enhanced manual scheduler initialized successfully');
            } catch (error) {
                console.error('❌ Error initializing scheduler:', error);
                showNotification('שגיאה בטעינת המערכת', 'error');
            }
        }
        
        // Event listeners setup
        function setupEventListeners() {
            // Month navigation
            document.getElementById('prev-month-btn').addEventListener('click', () => navigateMonth(-1));
            document.getElementById('next-month-btn').addEventListener('click', () => navigateMonth(1));
            
            // Action buttons
            document.getElementById('save-changes-btn').addEventListener('click', saveChanges);
            document.getElementById('clear-selection-btn').addEventListener('click', clearSelection);
            document.getElementById('undo-btn').addEventListener('click', undoLastAction);
            document.getElementById('redo-btn').addEventListener('click', redoLastAction);
            document.getElementById('clear-month-btn').addEventListener('click', clearMonth);
            document.getElementById('import-schedule-btn').addEventListener('click', importExistingSchedule);
            document.getElementById('bulk-mode-btn').addEventListener('click', toggleBulkMode);
            document.getElementById('refresh-btn').addEventListener('click', refreshData);
            
            // Bulk operation event listeners
            setupBulkOperationListeners();
            
            // Keyboard shortcuts
            document.addEventListener('keydown', handleKeyboardShortcuts);
            
            // Initialize mobile touch support
            setupMobileTouchSupport();
        }
        
        // Load month data
        async function loadMonthData() {
            try {
                showLoading(true);
                
                // Update display
                updateMonthDisplay();
                
                // Load weekend types first (needed for calendar rendering)
                await loadWeekendTypes();
                
                // Load guides with statistics
                await loadGuides();
                
                // Load calendar
                await loadCalendar();
                
                // Update status
                updateStatus();
                
            } catch (error) {
                console.error('Error loading month data:', error);
                showNotification('שגיאה בטעינת נתוני החודש', 'error');
            } finally {
                showLoading(false);
            }
        }
        
        // Load guides with statistics
        async function loadGuides() {
            try {
                const response = await apiFetch(`/api/enhanced-manual/guides/${currentYear}/${currentMonth}`);
                const data = await response.json();
                
                if (data.success) {
                    guides = data.guides;
                    renderGuideCards();
                    updateGuidesInfo();
                } else {
                    throw new Error(data.error || 'Failed to load guides');
                }
            } catch (error) {
                console.error('Error loading guides:', error);
                showNotification('שגיאה בטעינת המדריכים', 'error');
            }
        }
        
        // Render guide cards
        function renderGuideCards() {
            const container = document.getElementById('guides-container');
            container.innerHTML = '';
            
            guides.forEach(guide => {
                const card = createGuideCard(guide);
                container.appendChild(card);
            });
        }
        
        // Create guide card element
        function createGuideCard(guide) {
            const card = document.createElement('div');
            card.className = 'guide-card';
            card.draggable = true;
            card.dataset.guideId = guide.id;
            card.dataset.guideName = guide.name;
            
            // Accessibility attributes
            card.setAttribute('role', 'listitem');
            card.setAttribute('tabindex', '0');
            card.setAttribute('aria-label', `מדריך ${guide.name}, ${guide.total_shifts || 0} משמרות, ${(guide.salary_factor || 0).toFixed(1)} שעות שכר`);
            card.setAttribute('aria-describedby', `guide-${guide.id}-description`);
            
            // Check if guide has constraints this month
            const constraintCount = constraints[guide.id] ? constraints[guide.id].total_count : 0;
            
            // Add constraint indicator if needed
            let constraintIndicator = '';
            if (constraintCount > 0) {
                constraintIndicator = `<div class="guide-constraints-indicator">${constraintCount}</div>`;
            }
            
            // Calculate efficiency indicator (salary factor per shift)
            const efficiency = guide.total_shifts > 0 ? (guide.salary_factor / guide.total_shifts) : 0;
            let efficiencyClass = '';
            if (efficiency > 25) efficiencyClass = 'high-efficiency';
            else if (efficiency < 15) efficiencyClass = 'low-efficiency';
            
            card.innerHTML = `
                ${constraintIndicator}
                <div class="guide-name" aria-hidden="true">${guide.name}</div>
                <div class="guide-stats" aria-hidden="true">
                    <div class="shift-counter ${efficiencyClass}">${guide.total_shifts || 0}</div>
                    <div style="color: #6b7280; font-size: 0.8rem;">משמרות</div>
                </div>
                <div class="salary-hours" aria-hidden="true">${(guide.salary_factor || 0).toFixed(1)} שעות שכר</div>
                <div class="guide-efficiency" style="font-size: 0.7rem; color: #9ca3af; text-align: center;" aria-hidden="true">
                    ${efficiency.toFixed(1)} ש/משמרת
                </div>
                <div id="guide-${guide.id}-description" class="sr-only">
                    גרור מדריך זה לתאריך בלוח השיבוץ כדי לשבץ אותו. לחץ כדי לצפות באילוצים.
                    ${constraintCount > 0 ? `יש ${constraintCount} אילוצים בחודש זה.` : 'אין אילוצים בחודש זה.'}
                </div>
            `;
            
            // Add event listeners
            card.addEventListener('click', (e) => handleGuideCardClick(e, guide));
            card.addEventListener('dragstart', (e) => handleDragStart(e, guide));
            card.addEventListener('dragend', handleDragEnd);
            card.addEventListener('mouseenter', () => handleGuideHover(guide, true));
            card.addEventListener('mouseleave', () => handleGuideHover(guide, false));
            
            // Keyboard navigation support
            card.addEventListener('keydown', (e) => {
                switch(e.key) {
                    case 'Enter':
                    case ' ':
                        e.preventDefault();
                        handleGuideCardClick(e, guide);
                        break;
                    case 'ArrowRight':
                    case 'ArrowLeft':
                        e.preventDefault();
                        navigateGuideCards(card, e.key === 'ArrowRight' ? 1 : -1);
                        break;
                    case 'Home':
                        e.preventDefault();
                        focusFirstGuideCard();
                        break;
                    case 'End':
                        e.preventDefault();
                        focusLastGuideCard();
                        break;
                }
            });
            
            return card;
        }
        
        // Load calendar
        async function loadCalendar() {
            try {
                // Generate calendar grid
                await renderCalendarGrid();
                
                // Load existing assignments
                await loadAssignments();
                
            } catch (error) {
                console.error('Error loading calendar:', error);
                showNotification('שגיאה בטעינת הלוח', 'error');
            }
        }
        
        // Render calendar grid
        async function renderCalendarGrid() {
            const container = document.getElementById('calendar-grid');
            container.innerHTML = '';
            
            // Enhanced Hebrew day headers with full names
            const dayNames = [
                { short: 'א', full: 'ראשון' },
                { short: 'ב', full: 'שני' },
                { short: 'ג', full: 'שלישי' },
                { short: 'ד', full: 'רביעי' },
                { short: 'ה', full: 'חמישי' },
                { short: 'ו', full: 'שישי' },
                { short: 'ש', full: 'שבת' }
            ];
            
            dayNames.forEach((day, index) => {
                const header = document.createElement('div');
                header.className = 'calendar-day-header';
                
                // Add weekend class for Friday and Saturday
                if (index === 5 || index === 6) {
                    header.classList.add('weekend-header');
                }
                
                header.innerHTML = `
                    <span class="day-short">${day.short}</span>
                    <span class="day-full">${day.full}</span>
                `;
                header.title = day.full;
                container.appendChild(header);
            });
            
            // Generate days with enhanced weekend logic
            const firstDay = new Date(currentYear, currentMonth - 1, 1);
            const lastDay = new Date(currentYear, currentMonth, 0);
            const startDate = new Date(firstDay);
            
            // Israeli week starts on Sunday (day 0), so adjust accordingly
            const firstDayOfWeek = firstDay.getDay();
            startDate.setDate(startDate.getDate() - firstDayOfWeek);
            
            // Create all day elements asynchronously
            for (let i = 0; i < 42; i++) {
                const date = new Date(startDate);
                date.setDate(startDate.getDate() + i);
                
                const dayElement = await createDayElement(date);
                container.appendChild(dayElement);
            }
        }
        
        // Create day element with enhanced features
        async function createDayElement(date) {
            const day = document.createElement('div');
            day.className = 'calendar-day';
            day.dataset.date = formatLocalDate(date);
            
            // Enhanced date classification
            const isCurrentMonth = date.getMonth() === currentMonth - 1;
            const isToday = date.toDateString() === new Date().toDateString();
            const isFriday = date.getDay() === 5;
            const isSaturday = date.getDay() === 6;
            const isWeekend = isFriday || isSaturday;
            
            // Check for Jewish holidays asynchronously
            const holidays = await getHolidayInfo(date);
            const isHoliday = holidays.length > 0;
            
            // Apply CSS classes
            if (!isCurrentMonth) day.classList.add('other-month');
            if (isToday) day.classList.add('today');
            if (isWeekend) day.classList.add('weekend');
            if (isFriday) day.classList.add('friday');
            if (isSaturday) day.classList.add('saturday');
            if (isHoliday) day.classList.add('holiday');
            
            // Determine if this is a closed weekend day
            const isClosedWeekend = checkClosedWeekendStatus(date);
            if (isClosedWeekend) day.classList.add('closed-weekend');
            
                        // Create holiday indicators
            let holidayIndicators = '';
            if (isHoliday) {
              holidays.forEach(holiday => {
                const icon = jewishHolidays.getHolidayIcon(holiday.category);
                const color = jewishHolidays.getHolidayColor(holiday.category);
                const title = holiday.titleHeb || holiday.title;
                holidayIndicators += `<span class="holiday-indicator" style="color: ${color};" title="${title}">${icon}</span>`;
              });
            }
            
            // Create enhanced day structure
            day.innerHTML = `
                <div class="day-header">
                    <div class="day-number">${date.getDate()}</div>
                    ${isHoliday ? `<div class="holiday-title">${holidays[0].titleHeb || holidays[0].title}</div>` : ''}
                    <div class="day-indicators">
                        ${isToday ? '<span class="today-indicator">●</span>' : ''}
                        ${holidayIndicators}
                        ${isClosedWeekend ? '<span class="closed-indicator">🔒</span>' : ''}
                    </div>
                </div>
                <div class="day-slots">
                    <div class="day-slot normal-slot" data-slot="normal" data-date="${day.dataset.date}">
                        <div class="slot-header">
                            <span class="slot-label">רגיל</span>
                            <span class="slot-type-icon">👤</span>
                        </div>
                        <div class="slot-content">
                            <div class="assignment-placeholder">לחץ כאן לשיבוץ</div>
                        </div>
                        <div class="slot-actions">
                            <button class="remove-assignment" title="הסר שיבוץ">×</button>
                        </div>
                    </div>
                    <div class="day-slot overlap-slot" data-slot="overlap" data-date="${day.dataset.date}">
                        <div class="slot-header">
                            <span class="slot-label">חפיפה</span>
                            <span class="slot-type-icon">👥</span>
                        </div>
                        <div class="slot-content">
                            <div class="assignment-placeholder">לחץ כאן לשיבוץ</div>
                        </div>
                        <div class="slot-actions">
                            <button class="remove-assignment" title="הסר שיבוץ">×</button>
                        </div>
                    </div>
                </div>
                <div class="day-footer">
                    <div class="day-stats">
                        <span class="shift-count">0</span>
                    </div>
                </div>
            `;
            
            // Add enhanced drop event listeners
            const slots = day.querySelectorAll('.day-slot');
            slots.forEach(slot => {
                slot.addEventListener('dragover', handleSlotDragOver);
                slot.addEventListener('drop', handleSlotDrop);
                slot.addEventListener('dragenter', handleSlotDragEnter);
                slot.addEventListener('dragleave', handleSlotDragLeave);
                slot.addEventListener('click', handleSlotClick);
                slot.addEventListener('contextmenu', (e) => showContextMenu(e, slot));
                
                // Add removal button listeners
                const removeBtn = slot.querySelector('.remove-assignment');
                removeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    removeAssignment(slot.dataset.date, slot.dataset.slot);
                });
            });
            
            return day;
        }
        
        // Initialize Jewish holidays service
        const jewishHolidays = new JewishHolidaysService();
        
        // Check if date is a holiday (using Jewish holidays service)
        async function checkIfHoliday(date) {
            try {
                const dateString = formatLocalDate(date);
                const holidays = await jewishHolidays.getHolidaysForDate(dateString);
                return holidays.length > 0;
            } catch (error) {
                console.error('Error checking holidays:', error);
                return false;
            }
        }
        
        // Get holiday information for a date
        async function getHolidayInfo(date) {
            try {
                const dateString = formatLocalDate(date);
                return await jewishHolidays.getHolidaysForDate(dateString);
            } catch (error) {
                console.error('Error getting holiday info:', error);
                return [];
            }
            }
        
        // Enhanced Israeli weekend and holiday logic
        function getIsraeliDayInfo(date) {
            const dayOfWeek = date.getDay();
            const isFriday = dayOfWeek === 5;
            const isSaturday = dayOfWeek === 6;
            const isWeekend = isFriday || isSaturday;
            const isHoliday = checkIfHoliday(date);
            const isClosedWeekend = checkClosedWeekendStatus(date);
            
            return {
                isFriday,
                isSaturday,
                isWeekend,
                isHoliday,
                isClosedWeekend,
                isWorkingDay: !isWeekend && !isHoliday,
                weekendType: isClosedWeekend ? 'closed' : 'open'
            };
        }
        
        // Check closed weekend status for the date
        function checkClosedWeekendStatus(date) {
            // This integrates with the weekend_types system
            const dateStr = date.toISOString().split('T')[0];
            return weekendTypes[dateStr] === true;
        }
        
        // Load weekend types from API
        let weekendTypes = {};
        
        async function loadWeekendTypes() {
            try {
                const response = await apiFetch(`/api/weekend-types/${currentYear}/${currentMonth}`);
                const data = await response.json();
                
                if (data.success) {
                    weekendTypes = data.weekend_types || {};
                } else {
                    // Fallback: assume all Saturdays are closed
                    weekendTypes = {};
                    console.warn('Could not load weekend types, using fallback');
                }
            } catch (error) {
                console.error('Error loading weekend types:', error);
                // Fallback: assume all Saturdays are closed
                weekendTypes = {};
            }
        }
        
        // Utility functions
        function navigateMonth(direction) {
            currentMonth += direction;
            if (currentMonth > 12) {
                currentMonth = 1;
                currentYear++;
            } else if (currentMonth < 1) {
                currentMonth = 12;
                currentYear--;
            }
            loadMonthData();
        }
        
        function updateMonthDisplay() {
            const monthNames = [
                'ינואר', 'פברואר', 'מרץ', 'אפריל', 'מאי', 'יוני',
                'יולי', 'אוגוסט', 'ספטמבר', 'אוקטובר', 'נובמבר', 'דצמבר'
            ];
            
            document.getElementById('current-month-display').textContent = 
                `${monthNames[currentMonth - 1]} ${currentYear}`;
        }
        
        function showLoading(show) {
            const loadingElements = document.querySelectorAll('.loading');
            loadingElements.forEach(el => {
                el.classList.toggle('active', show);
            });
        }
        
        // Enhanced notification system with multiple notification support
        let notificationCounter = 0;
        let activeNotifications = new Map();
        
        function showNotification(message, type = 'success', duration = null, persistent = false) {
            const notificationId = ++notificationCounter;
            
            // Create notification container if it doesn't exist
            let notificationContainer = document.getElementById('notification-container');
            if (!notificationContainer) {
                notificationContainer = document.createElement('div');
                notificationContainer.id = 'notification-container';
                notificationContainer.style.cssText = `
                    position: fixed;
                    top: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    z-index: 10001;
                    direction: rtl;
                    max-width: 500px;
                    width: auto;
                    pointer-events: none;
                `;
                document.body.appendChild(notificationContainer);
            }
            
            // Determine notification settings
            const settings = getNotificationSettings(type);
            const notificationDuration = duration || settings.duration;
            
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `enhanced-notification ${type}`;
            notification.style.cssText = `
                background: white;
                border-radius: 8px;
                padding: 12px 16px;
                margin-bottom: 8px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
                border-right: 4px solid ${settings.color};
                display: flex;
                align-items: center;
                gap: 10px;
                font-size: 14px;
                color: #374151;
                animation: notificationSlideIn 0.3s ease-out;
                pointer-events: auto;
                max-width: 100%;
                word-wrap: break-word;
            `;
            
            // Add icon and content
            notification.innerHTML = `
                <span style="font-size: 18px; flex-shrink: 0;">${settings.icon}</span>
                <div style="flex: 1; line-height: 1.4;">${message}</div>
                ${!persistent ? '<button style="background: none; border: none; font-size: 16px; cursor: pointer; color: #6b7280; padding: 0; margin-right: 8px;" onclick="this.parentElement.remove()">×</button>' : ''}
            `;
            
            // Add to container
            notificationContainer.appendChild(notification);
            activeNotifications.set(notificationId, notification);
            
            // Auto-dismiss (if not persistent)
            if (!persistent && notificationDuration > 0) {
                setTimeout(() => {
                    dismissNotification(notificationId);
                }, notificationDuration);
            }
            
            // Return notification ID for manual dismissal
            return notificationId;
        }
        
        function getNotificationSettings(type) {
            const settings = {
                success: {
                    color: '#10b981',
                    icon: '✅',
                    duration: 3000
                },
                error: {
                    color: '#ef4444',
                    icon: '❌', 
                    duration: 5000
                },
                warning: {
                    color: '#f59e0b',
                    icon: '⚠️',
                    duration: 4000
                },
                info: {
                    color: '#3b82f6',
                    icon: 'ℹ️',
                    duration: 3000
                },
                loading: {
                    color: '#8b5cf6',
                    icon: '⏳',
                    duration: 0 // No auto-dismiss for loading
                }
            };
            
            return settings[type] || settings.info;
        }
        
        function dismissNotification(notificationId) {
            const notification = activeNotifications.get(notificationId);
            if (notification) {
                notification.style.animation = 'notificationSlideOut 0.3s ease-in forwards';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                    activeNotifications.delete(notificationId);
                }, 300);
            }
        }
        
        function dismissAllNotifications() {
            activeNotifications.forEach((notification, id) => {
                dismissNotification(id);
            });
        }
        
        // Notification shortcuts for common use cases
        function showSuccessNotification(message, duration) {
            return showNotification(message, 'success', duration);
        }
        
        function showErrorNotification(message, persistent = false) {
            return showNotification(message, 'error', persistent ? 0 : 5000, persistent);
        }
        
        function showWarningNotification(message, duration) {
            return showNotification(message, 'warning', duration);
        }
        
        function showInfoNotification(message, duration) {
            return showNotification(message, 'info', duration);
        }
        
        function showLoadingNotification(message) {
            return showNotification(message, 'loading', 0, true);
        }
        
        function showProgressNotification(message, progress = 0) {
            const notificationId = showLoadingNotification('');
            const notification = activeNotifications.get(notificationId);
            if (notification) {
                const progressBar = document.createElement('div');
                progressBar.style.cssText = `
                    width: 100%;
                    height: 4px;
                    background: #e5e7eb;
                    border-radius: 2px;
                    margin-top: 8px;
                    overflow: hidden;
                `;
                
                const progressFill = document.createElement('div');
                progressFill.style.cssText = `
                    height: 100%;
                    background: #8b5cf6;
                    border-radius: 2px;
                    transition: width 0.3s ease;
                    width: ${Math.max(0, Math.min(100, progress))}%;
                `;
                
                progressBar.appendChild(progressFill);
                notification.querySelector('div').innerHTML = message;
                notification.appendChild(progressBar);
                
                // Return update function
                return {
                    id: notificationId,
                    update: (newMessage, newProgress) => {
                        if (activeNotifications.has(notificationId)) {
                            notification.querySelector('div').textContent = newMessage || message;
                            progressFill.style.width = `${Math.max(0, Math.min(100, newProgress || progress))}%`;
                        }
                    },
                    complete: () => dismissNotification(notificationId)
                };
            }
            return null;
        }
        
        // Auto-save functionality
        let autoSaveEnabled = true;
        let autoSaveInterval = 30000; // 30 seconds
        let unsavedChanges = false;
        let lastSaveTime = null;
        let autoSaveTimer = null;
        let changeBuffer = [];
        
        function initAutoSave() {
            // Load auto-save preferences
            const savedPrefs = localStorage.getItem('schedulerAutoSave');
            if (savedPrefs) {
                const prefs = JSON.parse(savedPrefs);
                autoSaveEnabled = prefs.enabled !== false;
                autoSaveInterval = prefs.interval || 30000;
            }
            
            // Start auto-save timer if enabled
            if (autoSaveEnabled) {
                startAutoSaveTimer();
            }
            
            // Set up beforeunload warning for unsaved changes
            window.addEventListener('beforeunload', (e) => {
                if (unsavedChanges) {
                    e.preventDefault();
                    e.returnValue = 'יש לך שינויים לא שמורים. האם אתה בטוח שברצונך לעזוב?';
                    return e.returnValue;
                }
            });
            
            // Update save status indicator
            updateSaveStatusIndicator();
        }
        
        function markAsChanged(changeType, data = {}) {
            unsavedChanges = true;
            changeBuffer.push({
                type: changeType,
                data: data,
                timestamp: new Date()
            });
            
            updateSaveStatusIndicator();
            
            if (autoSaveEnabled) {
                // Debounce auto-save to avoid too frequent saves
                clearTimeout(autoSaveTimer);
                autoSaveTimer = setTimeout(performAutoSave, 3000); // 3 second delay after last change
            }
            
            showInfoNotification('שינוי זוהה - ישמר אוטומטית בקרוב...', 2000);
        }
        
        function clearChanges() {
            unsavedChanges = false;
            changeBuffer = [];
            lastSaveTime = new Date();
            updateSaveStatusIndicator();
        }
        
        async function performAutoSave() {
            if (!unsavedChanges || !autoSaveEnabled) return;
            
            try {
                const loadingId = showLoadingNotification('שומר אוטומטית...');
                
                // Perform the save operation
                const result = await saveScheduleData();
                
                dismissNotification(loadingId);
                
                if (result && result.success) {
                    clearChanges();
                    showSuccessNotification('נשמר אוטומטית בהצלחה', 2000);
                    console.log('📱 Auto-save completed successfully');
                } else {
                    showWarningNotification('שמירה אוטומטית נכשלה - נסה שמירה ידנית', 4000);
                }
                
            } catch (error) {
                console.error('Auto-save failed:', error);
                showErrorNotification('שמירה אוטומטית נכשלה: ' + error.message, true);
            }
        }
        
        function startAutoSaveTimer() {
            if (autoSaveTimer) clearInterval(autoSaveTimer);
            
            if (autoSaveEnabled && autoSaveInterval > 0) {
                autoSaveTimer = setInterval(() => {
                    if (unsavedChanges) {
                        performAutoSave();
                    }
                }, autoSaveInterval);
            }
        }
        
        function stopAutoSaveTimer() {
            if (autoSaveTimer) {
                clearInterval(autoSaveTimer);
                autoSaveTimer = null;
            }
        }
        
        function toggleAutoSave() {
            autoSaveEnabled = !autoSaveEnabled;
            
            // Save preference
            localStorage.setItem('schedulerAutoSave', JSON.stringify({
                enabled: autoSaveEnabled,
                interval: autoSaveInterval
            }));
            
            if (autoSaveEnabled) {
                startAutoSaveTimer();
                showSuccessNotification('שמירה אוטומטית הופעלה', 3000);
            } else {
                stopAutoSaveTimer();
                showInfoNotification('שמירה אוטומטית בוטלה', 3000);
            }
            
            updateSaveStatusIndicator();
        }
        
        function setAutoSaveInterval(minutes) {
            autoSaveInterval = minutes * 60 * 1000;
            localStorage.setItem('schedulerAutoSave', JSON.stringify({
                enabled: autoSaveEnabled,
                interval: autoSaveInterval
            }));
            
            if (autoSaveEnabled) {
                startAutoSaveTimer();
            }
            
            showInfoNotification(`מרווח שמירה אוטומטית עודכן ל-${minutes} דקות`, 3000);
        }
        
        function updateSaveStatusIndicator() {
            // Find or create save status indicator
            let statusIndicator = document.getElementById('save-status-indicator');
            if (!statusIndicator) {
                statusIndicator = document.createElement('div');
                statusIndicator.id = 'save-status-indicator';
                statusIndicator.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    background: white;
                    border-radius: 25px;
                    padding: 8px 16px;
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                    font-size: 12px;
                    color: #6b7280;
                    border: 1px solid #e5e7eb;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    z-index: 1000;
                    transition: all 0.3s ease;
                `;
                document.body.appendChild(statusIndicator);
            }
            
            let statusText, statusColor, statusIcon;
            
            if (unsavedChanges) {
                statusText = 'שינויים לא שמורים';
                statusColor = '#f59e0b';
                statusIcon = '⚠️';
            } else if (lastSaveTime) {
                const timeAgo = Math.floor((new Date() - lastSaveTime) / 1000);
                if (timeAgo < 60) {
                    statusText = 'נשמר כעת';
                } else if (timeAgo < 3600) {
                    statusText = `נשמר לפני ${Math.floor(timeAgo / 60)} דקות`;
                } else {
                    const hours = Math.floor(timeAgo / 3600);
                    statusText = `נשמר לפני ${hours} שע׳`;
                }
                statusColor = '#10b981';
                statusIcon = '✅';
            } else {
                statusText = autoSaveEnabled ? 'שמירה אוטומטית פעילה' : 'שמירה ידנית';
                statusColor = autoSaveEnabled ? '#3b82f6' : '#6b7280';
                statusIcon = autoSaveEnabled ? '🔄' : '💾';
            }
            
            statusIndicator.innerHTML = `
                <span style="font-size: 14px;">${statusIcon}</span>
                <span>${statusText}</span>
                ${autoSaveEnabled ? '<span style="font-size: 10px; opacity: 0.7;">אוטו</span>' : ''}
            `;
            statusIndicator.style.borderLeftColor = statusColor;
        }
        
        async function saveScheduleData() {
            // This should integrate with the existing save functionality
            // For now, we'll simulate a save operation
            return new Promise((resolve) => {
                setTimeout(() => {
                    resolve({ success: true });
                }, 500);
            });
        }
        
        function createAutoSaveControls() {
            const controlsContainer = document.createElement('div');
            controlsContainer.id = 'autosave-controls';
            controlsContainer.style.cssText = `
                display: none;
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: white;
                border-radius: 12px;
                padding: 20px;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                z-index: 10004;
                direction: rtl;
                min-width: 300px;
            `;
            
            controlsContainer.innerHTML = `
                <h3 style="margin: 0 0 20px 0; color: #374151;">הגדרות שמירה אוטומטית</h3>
                <div style="display: flex; flex-direction: column; gap: 15px;">
                    <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                        <input type="checkbox" ${autoSaveEnabled ? 'checked' : ''} onchange="toggleAutoSave()">
                        <span>הפעל שמירה אוטומטית</span>
                    </label>
                    <div>
                        <label style="display: block; margin-bottom: 8px; color: #6b7280;">מרווח שמירה (דקות):</label>
                        <select onchange="setAutoSaveInterval(this.value)" ${!autoSaveEnabled ? 'disabled' : ''}>
                            <option value="0.5" ${autoSaveInterval === 30000 ? 'selected' : ''}>30 שניות</option>
                            <option value="1" ${autoSaveInterval === 60000 ? 'selected' : ''}>1 דקה</option>
                            <option value="2" ${autoSaveInterval === 120000 ? 'selected' : ''}>2 דקות</option>
                            <option value="5" ${autoSaveInterval === 300000 ? 'selected' : ''}>5 דקות</option>
                            <option value="10" ${autoSaveInterval === 600000 ? 'selected' : ''}>10 דקות</option>
                        </select>
                    </div>
                    <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 15px;">
                        <button onclick="document.getElementById('autosave-controls').style.display='none'" 
                                style="padding: 8px 16px; border: 1px solid #d1d5db; background: white; border-radius: 6px; cursor: pointer;">
                            סגור
                        </button>
                        <button onclick="performAutoSave(); document.getElementById('autosave-controls').style.display='none'" 
                                style="padding: 8px 16px; border: none; background: #8b5cf6; color: white; border-radius: 6px; cursor: pointer;">
                            שמור עכשיו
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(controlsContainer);
        }
        
        function showAutoSaveControls() {
            let controls = document.getElementById('autosave-controls');
            if (!controls) {
                createAutoSaveControls();
                controls = document.getElementById('autosave-controls');
            }
            controls.style.display = 'block';
        }
        
        // Integration with existing save/change functions
        const originalCreateAssignmentFromContext = createAssignmentFromContext;
        async function createAssignmentFromContext(guideId, date, slotType) {
            try {
                await originalCreateAssignmentFromContext(guideId, date, slotType);
                markAsChanged('assignment_create', { guideId, date, slotType });
            } catch (error) {
                throw error;
            }
        }
        
        const originalRemoveAssignmentFromSlotForAutoSave = removeAssignmentFromSlot;
        async function removeAssignmentFromSlotForAutoSave(date, slotType, skipConfirmation = false) {
            try {
                const result = await originalRemoveAssignmentFromSlotForAutoSave(date, slotType, skipConfirmation);
                markAsChanged('assignment_remove', { date, slotType });
                return result;
            } catch (error) {
                throw error;
            }
        }
        
        // Offline/Connection Error Handling
        let isOnline = navigator.onLine;
        let connectionRetryAttempts = 0;
        let maxRetryAttempts = 3;
        let retryDelay = 2000; // 2 seconds
        let offlineQueue = [];
        let networkStatusIndicator = null;
        
        function initOfflineHandling() {
            // Listen for online/offline events
            window.addEventListener('online', handleOnline);
            window.addEventListener('offline', handleOffline);
            
            // Initial connection check
            checkConnectionStatus();
            
            // Create network status indicator
            createNetworkStatusIndicator();
            
            // Periodic connection check (every 30 seconds when offline)
            setInterval(() => {
                if (!isOnline) {
                    checkConnectionStatus();
                }
            }, 30000);
        }
        
        function handleOnline() {
            console.log('📡 Connection restored');
            isOnline = true;
            connectionRetryAttempts = 0;
            updateNetworkStatusIndicator();
            
            showSuccessNotification('החיבור לאינטרנט חזר!', 3000);
            
            // Process offline queue
            processOfflineQueue();
        }
        
        function handleOffline() {
            console.log('📡 Connection lost');
            isOnline = false;
            updateNetworkStatusIndicator();
            
            showWarningNotification('אין חיבור לאינטרנט - נתונים יישמרו מקומית', 5000);
        }
        
        async function checkConnectionStatus() {
            try {
                const response = await fetch('/api/health', {
                    method: 'GET',
                    cache: 'no-cache',
                    timeout: 5000
                });
                
                const wasOffline = !isOnline;
                isOnline = response.ok;
                
                if (wasOffline && isOnline) {
                    handleOnline();
                } else if (!wasOffline && !isOnline) {
                    handleOffline();
                }
                
                updateNetworkStatusIndicator();
            } catch (error) {
                console.log('Connection check failed:', error.message);
                if (isOnline) {
                    handleOffline();
                }
            }
        }
        
        function createNetworkStatusIndicator() {
            networkStatusIndicator = document.createElement('div');
            networkStatusIndicator.id = 'network-status-indicator';
            networkStatusIndicator.style.cssText = `
                position: fixed;
                bottom: 20px;
                left: 20px;
                background: white;
                border-radius: 25px;
                padding: 8px 12px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                font-size: 12px;
                color: #6b7280;
                border: 1px solid #e5e7eb;
                display: flex;
                align-items: center;
                gap: 6px;
                z-index: 1000;
                transition: all 0.3s ease;
                cursor: pointer;
            `;
            
            networkStatusIndicator.addEventListener('click', () => {
                if (!isOnline) {
                    checkConnectionStatus();
                    showInfoNotification('בודק חיבור...', 2000);
                }
            });
            
            document.body.appendChild(networkStatusIndicator);
            updateNetworkStatusIndicator();
        }
        
        function updateNetworkStatusIndicator() {
            if (!networkStatusIndicator) return;
            
            let statusText, statusColor, statusIcon;
            
            if (isOnline) {
                statusText = 'מחובר';
                statusColor = '#10b981';
                statusIcon = '🌐';
                networkStatusIndicator.style.opacity = '0.7';
            } else {
                statusText = 'לא מחובר';
                statusColor = '#ef4444';
                statusIcon = '📵';
                networkStatusIndicator.style.opacity = '1';
            }
            
            networkStatusIndicator.innerHTML = `
                <span style="font-size: 14px;">${statusIcon}</span>
                <span>${statusText}</span>
            `;
            networkStatusIndicator.style.borderLeftColor = statusColor;
        }
        
        async function executeWithRetry(operation, operationName, retryCount = 0) {
            try {
                const result = await operation();
                connectionRetryAttempts = 0; // Reset on success
                return result;
            } catch (error) {
                console.error(`${operationName} failed (attempt ${retryCount + 1}):`, error);
                
                // Check if it's a network error
                if (isNetworkError(error)) {
                    if (!isOnline) {
                        // Store in offline queue
                        addToOfflineQueue(operation, operationName);
                        showWarningNotification(`${operationName} נשמר לביצוע כשהחיבור יחזור`, 4000);
                        return { queued: true };
                    }
                    
                    // Retry if online but connection failed
                    if (retryCount < maxRetryAttempts) {
                        connectionRetryAttempts++;
                        showInfoNotification(`מנסה שוב (ניסיון ${retryCount + 2}/${maxRetryAttempts + 1})...`, 3000);
                        
                        await new Promise(resolve => setTimeout(resolve, retryDelay * (retryCount + 1)));
                        return executeWithRetry(operation, operationName, retryCount + 1);
                    }
                }
                
                // Max retries exceeded or non-network error
                showErrorNotification(`${operationName} נכשל: ${error.message}`, true);
                throw error;
            }
        }
        
        function isNetworkError(error) {
            return error.name === 'TypeError' ||
                   error.name === 'NetworkError' ||
                   error.message.includes('Failed to fetch') ||
                   error.message.includes('Network Error') ||
                   error.message.includes('ERR_NETWORK') ||
                   error.message.includes('ERR_INTERNET_DISCONNECTED');
        }
        
        function addToOfflineQueue(operation, operationName) {
            offlineQueue.push({
                operation,
                operationName,
                timestamp: new Date(),
                id: Date.now()
            });
            
            // Store in localStorage for persistence
            localStorage.setItem('schedulerOfflineQueue', JSON.stringify(offlineQueue.map(item => ({
                operationName: item.operationName,
                timestamp: item.timestamp,
                id: item.id
            }))));
        }
        
        async function processOfflineQueue() {
            if (offlineQueue.length === 0) return;
            
            const progressNotification = showProgressNotification('מסנכרן נתונים...', 0);
            let processedCount = 0;
            const totalItems = offlineQueue.length;
            
            const itemsToProcess = [...offlineQueue];
            offlineQueue = [];
            
            for (const item of itemsToProcess) {
                try {
                    await item.operation();
                    processedCount++;
                    progressNotification.update(
                        `מסנכרן נתונים... (${processedCount}/${totalItems})`,
                        (processedCount / totalItems) * 100
                    );
                    
                    console.log(`✅ Offline operation completed: ${item.operationName}`);
                } catch (error) {
                    console.error(`❌ Failed to process offline operation: ${item.operationName}`, error);
                    // Re-add to queue for later retry
                    offlineQueue.push(item);
                }
            }
            
            progressNotification.complete();
            
            // Clear localStorage
            localStorage.removeItem('schedulerOfflineQueue');
            
            if (processedCount > 0) {
                showSuccessNotification(`${processedCount} פעולות סונכרנו בהצלחה`, 4000);
            }
            
            if (offlineQueue.length > 0) {
                showWarningNotification(`${offlineQueue.length} פעולות עדיין ממתינות לסנכרון`, 4000);
            }
        }
        
        // Enhanced API wrapper with offline support
        async function apiRequest(url, options = {}) {
            const operation = async () => {
                const response = await fetch(url, {
                    ...options,
                    headers: {
                        'Content-Type': 'application/json',
                        ...options.headers
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                return response.json();
            };
            
            return executeWithRetry(operation, `API ${options.method || 'GET'} ${url}`);
        }
        
        // Offline-aware save operation
        async function saveWithOfflineSupport(data, operationName = 'שמירה') {
            if (!isOnline) {
                // Store locally
                const offlineData = {
                    data,
                    operationName,
                    timestamp: new Date(),
                    id: Date.now()
                };
                
                let offlineStorage = JSON.parse(localStorage.getItem('schedulerOfflineData') || '[]');
                offlineStorage.push(offlineData);
                localStorage.setItem('schedulerOfflineData', JSON.stringify(offlineStorage));
                
                showWarningNotification(`${operationName} נשמר מקומית - יסונכרן כשהחיבור יחזור`, 4000);
                return { offline: true, id: offlineData.id };
            }
            
            try {
                const result = await apiRequest('/api/save', {
                    method: 'POST',
                    body: JSON.stringify(data)
                });
                
                showSuccessNotification(`${operationName} הושלם בהצלחה`, 3000);
                return result;
            } catch (error) {
                showErrorNotification(`${operationName} נכשל: ${error.message}`);
                throw error;
            }
        }
        
        function createOfflineControls() {
            const controlsContainer = document.createElement('div');
            controlsContainer.id = 'offline-controls';
            controlsContainer.style.cssText = `
                display: none;
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: white;
                border-radius: 12px;
                padding: 20px;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                z-index: 10005;
                direction: rtl;
                min-width: 350px;
                max-width: 500px;
            `;
            
            updateOfflineControlsContent(controlsContainer);
            document.body.appendChild(controlsContainer);
        }
        
        function updateOfflineControlsContent(container) {
            const queueCount = offlineQueue.length;
            const offlineData = JSON.parse(localStorage.getItem('schedulerOfflineData') || '[]');
            const localDataCount = offlineData.length;
            
            container.innerHTML = `
                <h3 style="margin: 0 0 20px 0; color: #374151;">מצב לא מקוון</h3>
                <div style="display: flex; flex-direction: column; gap: 15px;">
                    <div style="padding: 12px; background: #f3f4f6; border-radius: 6px;">
                        <div style="font-weight: 500; margin-bottom: 8px;">מצב חיבור: ${isOnline ? '🌐 מחובר' : '📵 לא מחובר'}</div>
                        <div style="font-size: 13px; color: #6b7280;">
                            ${isOnline ? 'מערכת פועלת במצב מקוון רגיל' : 'מערכת פועלת במצב לא מקוון - שינויים נשמרים מקומית'}
                        </div>
                    </div>
                    
                    ${queueCount > 0 ? `
                        <div style="padding: 12px; background: #fef3c7; border-radius: 6px; border-right: 4px solid #f59e0b;">
                            <div style="font-weight: 500; margin-bottom: 4px;">⏳ ${queueCount} פעולות ממתינות לסנכרון</div>
                            <button onclick="processOfflineQueue()" style="margin-top: 8px; padding: 6px 12px; border: none; background: #f59e0b; color: white; border-radius: 4px; cursor: pointer;">
                                סנכרן עכשיו
                            </button>
                        </div>
                    ` : ''}
                    
                    ${localDataCount > 0 ? `
                        <div style="padding: 12px; background: #dbeafe; border-radius: 6px; border-right: 4px solid #3b82f6;">
                            <div style="font-weight: 500; margin-bottom: 4px;">💾 ${localDataCount} נתונים מקומיים</div>
                            <div style="font-size: 13px; color: #6b7280;">נתונים שנשמרו מקומית ויסונכרנו כשהחיבור יחזור</div>
                        </div>
                    ` : ''}
                    
                    <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 15px;">
                        <button onclick="document.getElementById('offline-controls').style.display='none'" 
                                style="padding: 8px 16px; border: 1px solid #d1d5db; background: white; border-radius: 6px; cursor: pointer;">
                            סגור
                        </button>
                        <button onclick="checkConnectionStatus(); document.getElementById('offline-controls').style.display='none'" 
                                style="padding: 8px 16px; border: none; background: #3b82f6; color: white; border-radius: 6px; cursor: pointer;">
                            בדוק חיבור
                        </button>
                    </div>
                </div>
            `;
        }
        
        function showOfflineControls() {
            let controls = document.getElementById('offline-controls');
            if (!controls) {
                createOfflineControls();
                controls = document.getElementById('offline-controls');
            } else {
                updateOfflineControlsContent(controls);
            }
            controls.style.display = 'block';
        }
        
        // Guide card interaction handlers
        function handleGuideCardClick(e, guide) {
            e.preventDefault();
            e.stopPropagation();
            
            // Toggle selection
            if (selectedGuide && selectedGuide.id === guide.id) {
                clearGuideSelection();
            } else {
                selectGuide(guide);
            }
        }
        
        function selectGuide(guide) {
            console.log('🎯 Selected guide:', guide.name);
            
            // Update global state
            selectedGuide = guide;
            
            // Update visual selection
            updateGuideCardSelection();
            
            // Load and display constraints for this guide
            loadGuideConstraints(guide.id);
            
            // Update status display
            updateSelectedGuideDisplay();
            
            // Highlight available slots on calendar
            highlightAvailableSlots();
            
            showNotification(`נבחר מדריך: ${guide.name}`, 'success');
        }
        
        function clearGuideSelection() {
            console.log('🔄 Clearing guide selection');
            
            selectedGuide = null;
            updateGuideCardSelection();
            clearConstraintHighlights();
            clearSlotHighlights();
            updateSelectedGuideDisplay();
            
            showNotification('הבחירה נוקתה', 'success');
        }
        
        function updateGuideCardSelection() {
            // Remove selection from all cards
            document.querySelectorAll('.guide-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            // Add selection to current card
            if (selectedGuide) {
                const selectedCard = document.querySelector(`[data-guide-id="${selectedGuide.id}"]`);
                if (selectedCard) {
                    selectedCard.classList.add('selected');
                }
            }
        }
        
        function handleGuideHover(guide, isEntering) {
            if (isEntering && !selectedGuide) {
                // Show preview of constraints for this guide
                previewGuideConstraints(guide.id);
            } else if (!isEntering && !selectedGuide) {
                // Clear preview
                clearConstraintHighlights();
            }
        }
        
        // Constraint loading and visualization
        async function loadGuideConstraints(guideId) {
            try {
                const response = await apiFetch(`/api/enhanced-manual/constraints/${guideId}/${currentYear}/${currentMonth}`);
                const data = await response.json();
                
                if (data.success) {
                    constraints[guideId] = data.constraints;
                    visualizeConstraints(data.constraints);
                    updateConstraintsDisplay(data.constraints);
                } else {
                    throw new Error(data.error || 'Failed to load constraints');
                }
            } catch (error) {
                console.error('Error loading constraints:', error);
                showNotification('שגיאה בטעינת אילוצים', 'error');
            }
        }
        
        async function previewGuideConstraints(guideId) {
            // Quick preview without full loading
            if (constraints[guideId]) {
                visualizeConstraints(constraints[guideId]);
            }
        }
        
        function visualizeConstraints(constraintData) {
            clearConstraintHighlights();
            
            console.log('🎨 Visualizing constraints:', constraintData);
            
            // Track constraint counts for display
            let constraintCounts = {
                regular: 0,
                fixed: 0,
                vacation: 0,
                dynamic: 0,
                total: 0
            };
            
            // Highlight regular constraints
            if (constraintData.regular && constraintData.regular.length > 0) {
                constraintData.regular.forEach(constraint => {
                    highlightConstraintDate(constraint.date, 'regular', constraint.details, constraint.reason);
                    constraintCounts.regular++;
                });
            }
            
            // Highlight fixed constraints (weekly recurring)
            if (constraintData.fixed && constraintData.fixed.length > 0) {
                constraintData.fixed.forEach(constraint => {
                    const affectedDays = highlightFixedConstraintDays(constraint.weekday, constraint.details, constraint.reason);
                    constraintCounts.fixed += affectedDays;
                });
            }
            
            // Highlight vacation constraints
            if (constraintData.vacations && constraintData.vacations.length > 0) {
                constraintData.vacations.forEach(vacation => {
                    const affectedDays = highlightVacationPeriod(vacation.date_start, vacation.date_end, vacation.details, vacation.reason);
                    constraintCounts.vacation += affectedDays;
                });
            }
            
            // Generate and highlight dynamic constraints (consecutive days)
            if (selectedGuide) {
                const dynamicConstraints = generateDynamicConstraints(selectedGuide.id);
                dynamicConstraints.forEach(dynamic => {
                    highlightConstraintDate(dynamic.date, 'dynamic', dynamic.details, dynamic.reason);
                    constraintCounts.dynamic++;
                });
            }
            
            // Add pre-existing dynamic constraints from API
            if (constraintData.dynamic && constraintData.dynamic.length > 0) {
                constraintData.dynamic.forEach(dynamic => {
                    highlightConstraintDate(dynamic.date, 'dynamic', dynamic.details, dynamic.reason);
                    constraintCounts.dynamic++;
                });
            }
            
            // Calculate total constraints
            constraintCounts.total = constraintCounts.regular + constraintCounts.fixed + constraintCounts.vacation + constraintCounts.dynamic;
            
            // Update constraint display in status bar
            updateConstraintsDisplay(constraintCounts);
            
            // Update available drop zones based on constraints
            updateDropZoneAvailability();
            
            console.log('📊 Constraint counts:', constraintCounts);
        }
        
        function highlightConstraintDate(date, type, details, reason) {
            const dayElement = document.querySelector(`[data-date="${date}"]`);
            if (dayElement) {
                dayElement.classList.add('has-constraint', `constraint-${type}`);
                
                // Create detailed tooltip with Hebrew text
                const tooltipText = createConstraintTooltip(type, details, reason, date);
                dayElement.title = tooltipText;
                
                // Add enhanced constraint overlay
                if (!dayElement.querySelector('.constraint-overlay')) {
                    const overlay = document.createElement('div');
                    overlay.className = `constraint-overlay constraint-overlay-${type}`;
                    
                    // Add constraint icon based on type
                    const icon = getConstraintIcon(type);
                    overlay.innerHTML = `
                        <div class="constraint-icon">${icon}</div>
                        <div class="constraint-pattern"></div>
                    `;
                    
                    dayElement.appendChild(overlay);
                    
                    // Add constraint info badge
                    const info = document.createElement('div');
                    info.className = `constraint-info constraint-info-${type}`;
                    info.innerHTML = `
                        <span class="constraint-type-label">${getConstraintTypeLabel(type)}</span>
                        <span class="constraint-reason-short">${getShortReason(reason, type)}</span>
                    `;
                    info.title = tooltipText;
                    dayElement.appendChild(info);
                    
                    // Add click handler for detailed constraint info
                    info.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showConstraintDetails(date, type, details, reason);
                    });
                }
                
                // Also add constraint to specific slots if applicable
                addConstraintToSlots(dayElement, type);
            }
        }
        
        function createConstraintTooltip(type, details, reason, date) {
            const formattedDate = formatDateForDisplay(date);
            const typeLabel = getConstraintTypeLabel(type);
            
            let tooltip = `${typeLabel} - ${formattedDate}\n`;
            
            if (reason) {
                tooltip += `סיבה: ${reason}\n`;
            }
            
            if (details) {
                tooltip += `פרטים: ${details}\n`;
            }
            
            // Add specific information based on constraint type
            switch (type) {
                case 'regular':
                    tooltip += 'אילוץ ספציפי לתאריך זה';
                    break;
                case 'fixed':
                    tooltip += 'אילוץ קבוע שחוזר מדי שבוע';
                    break;
                case 'vacation':
                    tooltip += 'חופשה או חוסר זמינות';
                    break;
                case 'dynamic':
                    tooltip += 'אילוץ דינמי (מניעת ימים רצופים)';
                    break;
            }
            
            return tooltip;
        }
        
        function getConstraintIcon(type) {
            const icons = {
                regular: '🚫',
                fixed: '📅',
                vacation: '🌴',
                dynamic: '⚠️'
            };
            return icons[type] || '❌';
        }
        
        function getConstraintTypeLabel(type) {
            const labels = {
                regular: 'אילוץ רגיל',
                fixed: 'אילוץ קבוע',
                vacation: 'חופשה',
                dynamic: 'אילוץ דינמי'
            };
            return labels[type] || 'אילוץ';
        }
        
        function getShortReason(reason, type) {
            if (reason && reason.length > 20) {
                return reason.substring(0, 17) + '...';
            }
            return reason || getConstraintTypeLabel(type);
        }
        
        function addConstraintToSlots(dayElement, type) {
            const slots = dayElement.querySelectorAll('.day-slot');
            slots.forEach(slot => {
                slot.classList.add('slot-has-constraint', `slot-constraint-${type}`);
                
                // Disable drop zone functionality for constrained slots
                slot.classList.remove('drop-zone');
                slot.classList.add('constraint-blocked');
            });
        }
        
        function showConstraintDetails(date, type, details, reason) {
            const formattedDate = formatDateForDisplay(date);
            const typeLabel = getConstraintTypeLabel(type);
            
            let message = `<strong>${typeLabel}</strong><br>`;
            message += `תאריך: ${formattedDate}<br>`;
            
            if (reason) {
                message += `סיבה: ${reason}<br>`;
            }
            
            if (details) {
                message += `פרטים: ${details}<br>`;
            }
            
            // Add action buttons for constraint management
            message += `<br><div class="constraint-actions">`;
            if (type === 'dynamic') {
                message += `<small>אילוץ זה נוצר אוטומטית למניעת ימים רצופים</small>`;
            } else {
                message += `<small>לעריכה או מחיקה, עבור לעמוד האילוצים</small>`;
            }
            message += `</div>`;
            
            showNotification(message, 'info', 5000);
        }
        
        function highlightFixedConstraintDays(weekday, details, reason) {
            // Highlight all days of this weekday in the month
            const dayElements = document.querySelectorAll('.calendar-day');
            let affectedDays = 0;
            
            dayElements.forEach(dayElement => {
                const date = new Date(dayElement.dataset.date);
                // Check if this day matches the constraint weekday and is in current month
                if (date.getDay() === weekday && date.getMonth() === currentMonth - 1) {
                    highlightConstraintDate(dayElement.dataset.date, 'fixed', details, reason);
                    affectedDays++;
                }
            });
            
            return affectedDays;
        }
        
        function highlightVacationPeriod(startDate, endDate, details, reason) {
            // Parse dates using local timezone to avoid UTC offset issues
            const start = parseLocalDate(startDate);
            const end = parseLocalDate(endDate);
            let affectedDays = 0;
            
            for (let date = new Date(start); date <= end; date.setDate(date.getDate() + 1)) {
                const dateStr = formatLocalDate(date);
                
                // Only highlight dates within current month view
                if (date.getMonth() === currentMonth - 1 || date.getFullYear() === currentYear) {
                    highlightConstraintDate(dateStr, 'vacation', details, reason);
                    affectedDays++;
                }
            }
            
            return affectedDays;
        }
        
        // Dynamic constraint generation for consecutive day prevention
        function generateDynamicConstraints(guideId) {
            const dynamicConstraints = [];
            
            if (!assignments || assignments.length === 0) {
                return dynamicConstraints;
            }
            
            // Find all assignments for this guide in the current month
            const guideAssignments = assignments.filter(assignment => 
                assignment.guide1_id === guideId || assignment.guide2_id === guideId
            );
            
            if (guideAssignments.length === 0) {
                return dynamicConstraints;
            }
            
            // For each assignment, add constraints for consecutive days
            guideAssignments.forEach(assignment => {
                const assignmentDate = new Date(assignment.date);
                
                // Add constraint for day before assignment (prevent consecutive)
                const dayBefore = new Date(assignmentDate);
                dayBefore.setDate(dayBefore.getDate() - 1);
                
                // Add constraint for day after assignment (prevent consecutive)
                const dayAfter = new Date(assignmentDate);
                dayAfter.setDate(dayAfter.getDate() + 1);
                
                // Check if these days fall within current month view
                const currentMonthStart = new Date(currentYear, currentMonth - 1, 1);
                const currentMonthEnd = new Date(currentYear, currentMonth, 0);
                
                if (dayBefore >= currentMonthStart && dayBefore <= currentMonthEnd) {
                    // Check if it's a special case (Friday-Saturday pairing for closed weekends)
                    const isSpecialCase = checkConsecutiveDayException(assignment.date, dayBefore.toISOString().split('T')[0]);
                    
                    if (!isSpecialCase) {
                        dynamicConstraints.push({
                            date: dayBefore.toISOString().split('T')[0],
                            details: 'מניעת ימים רצופים',
                            reason: `למניעת יום רצוף עם ${formatDateForDisplay(assignment.date)}`,
                            sourceDate: assignment.date,
                            type: 'consecutive_before'
                        });
                    }
                }
                
                if (dayAfter >= currentMonthStart && dayAfter <= currentMonthEnd) {
                    // Check if it's a special case (Friday-Saturday pairing for closed weekends)
                    const isSpecialCase = checkConsecutiveDayException(assignment.date, dayAfter.toISOString().split('T')[0]);
                    
                    if (!isSpecialCase) {
                        dynamicConstraints.push({
                            date: dayAfter.toISOString().split('T')[0],
                            details: 'מניעת ימים רצופים',
                            reason: `למניעת יום רצוף עם ${formatDateForDisplay(assignment.date)}`,
                            sourceDate: assignment.date,
                            type: 'consecutive_after'
                        });
                    }
                }
            });
            
            return dynamicConstraints;
        }
        
        // Check for consecutive day exceptions (like Friday-Saturday for closed weekends)
        function checkConsecutiveDayException(date1, date2) {
            const d1 = new Date(date1);
            const d2 = new Date(date2);
            
            // Check if this is a Friday-Saturday pair
            const isFridayToSaturday = (d1.getDay() === 5 && d2.getDay() === 6) || 
                                     (d1.getDay() === 6 && d2.getDay() === 5);
            
            if (isFridayToSaturday) {
                // Check if Saturday is a closed weekend
                const saturday = d1.getDay() === 6 ? d1 : d2;
                const saturdayStr = saturday.toISOString().split('T')[0];
                
                if (weekendTypes[saturdayStr] === true) {
                    // This is a closed weekend, so Friday-Saturday consecutive is allowed
                    return true;
                }
            }
            
            return false;
        }
        
        function clearConstraintHighlights() {
            document.querySelectorAll('.calendar-day').forEach(day => {
                day.classList.remove('has-constraint', 'constraint-regular', 'constraint-fixed', 'constraint-vacation', 'constraint-dynamic');
                day.removeAttribute('title');
                
                // Remove constraint overlays
                const overlay = day.querySelector('.constraint-overlay');
                if (overlay) overlay.remove();
                
                // Remove constraint info badges
                const info = day.querySelector('.constraint-info');
                if (info) info.remove();
                
                // Clear slot constraints
                const slots = day.querySelectorAll('.day-slot');
                slots.forEach(slot => {
                    slot.classList.remove('slot-has-constraint', 'slot-constraint-regular', 'slot-constraint-fixed', 'slot-constraint-vacation', 'slot-constraint-dynamic', 'constraint-blocked');
                });
            });
        }
        
        // Update drop zone availability based on constraints
        function updateDropZoneAvailability() {
            if (!selectedGuide) return;
            
            // Clear existing drop zones
            clearSlotHighlights();
            
            // Add drop zones to available slots
            document.querySelectorAll('.calendar-day').forEach(day => {
                if (!day.classList.contains('other-month')) {
                    const slots = day.querySelectorAll('.day-slot');
                    slots.forEach(slot => {
                        // Only allow drops on slots that are not occupied and not constrained
                        if (!slot.classList.contains('occupied') && !slot.classList.contains('constraint-blocked')) {
                            slot.classList.add('drop-zone');
                        }
                    });
                }
            });
        }
        
        // Handle constraint updates after new assignments
        function updateConstraintsAfterAssignment(guideId, date, slotType) {
            console.log('🔄 Updating constraints after assignment:', { guideId, date, slotType });
            
            // If a guide is currently selected, refresh their constraints
            if (selectedGuide && selectedGuide.id === guideId) {
                // Reload constraints to get updated dynamic constraints
                setTimeout(() => {
                    loadGuideConstraints(guideId);
                }, 100);
            }
            
            // Update all other visible guides if they have overlapping constraints
            guides.forEach(guide => {
                if (guide.id !== guideId && constraints[guide.id]) {
                    // Check if this guide might be affected by dynamic constraints
                    const nearbyDates = [
                        new Date(date + 'T00:00:00'),
                        new Date(new Date(date + 'T00:00:00').getTime() - 24 * 60 * 60 * 1000),
                        new Date(new Date(date + 'T00:00:00').getTime() + 24 * 60 * 60 * 1000)
                    ];
                    
                    // This is a simplified check - in a full implementation you'd want more sophisticated logic
                    console.log(`Checking if guide ${guide.name} needs constraint updates...`);
                }
            });
        }
        
        // Enhanced constraints display update
        function updateConstraintsDisplay(constraintCounts) {
            const constraintsCountElement = document.getElementById('constraints-count');
            if (constraintsCountElement && constraintCounts) {
                const totalConstraints = constraintCounts.total || 0;
                
                let displayText = `${totalConstraints} אילוצים`;
                
                if (totalConstraints > 0) {
                    const breakdown = [];
                    if (constraintCounts.regular > 0) breakdown.push(`${constraintCounts.regular} רגילים`);
                    if (constraintCounts.fixed > 0) breakdown.push(`${constraintCounts.fixed} קבועים`);
                    if (constraintCounts.vacation > 0) breakdown.push(`${constraintCounts.vacation} חופשות`);
                    if (constraintCounts.dynamic > 0) breakdown.push(`${constraintCounts.dynamic} דינמיים`);
                    
                    if (breakdown.length > 0) {
                        displayText += ` (${breakdown.join(', ')})`;
                    }
                }
                
                constraintsCountElement.textContent = displayText;
                constraintsCountElement.title = 'לחץ על יום עם אילוץ לפרטים נוספים';
            }
        }
        
        function highlightAvailableSlots() {
            if (!selectedGuide) return;
            
            document.querySelectorAll('.calendar-day').forEach(day => {
                if (!day.classList.contains('has-constraint') && !day.classList.contains('other-month')) {
                    const slots = day.querySelectorAll('.day-slot');
                    slots.forEach(slot => {
                        if (!slot.classList.contains('occupied')) {
                            slot.classList.add('drop-zone');
                        }
                    });
                }
            });
        }
        
        function clearSlotHighlights() {
            document.querySelectorAll('.day-slot').forEach(slot => {
                slot.classList.remove('drop-zone', 'drop-invalid');
            });
        }
        
        // Drag and Drop Implementation
        let draggedGuide = null;
        let dragGhost = null;
        
        function handleDragStart(e, guide) {
            console.log('🖱️ Drag start:', guide.name);
            
            draggedGuide = guide;
            
            // Create drag ghost element
            createDragGhost(e, guide);
            
            // Add dragging class to card
            e.target.classList.add('dragging');
            
            // Set drag data
            e.dataTransfer.setData('text/plain', guide.id);
            e.dataTransfer.effectAllowed = 'move';
            
            // Highlight possible drop zones
            highlightDropZones();
        }
        
        function handleDragEnd(e) {
            console.log('🖱️ Drag end');
            
            // Clean up
            e.target.classList.remove('dragging');
            clearDropZoneHighlights();
            removeDragGhost();
            
            // Don't reset draggedGuide immediately - let the drop handler process first
            setTimeout(() => {
                draggedGuide = null;
            }, 100);
        }
        
        function createDragGhost(e, guide) {
            dragGhost = document.createElement('div');
            dragGhost.className = 'drag-ghost guide-card';
            dragGhost.innerHTML = `
                <div class="guide-name">${guide.name}</div>
                <div class="shift-counter">${guide.total_shifts || 0}</div>
            `;
            
            document.body.appendChild(dragGhost);
            
            // Position ghost at cursor
            updateDragGhostPosition(e);
            
            // Hide default drag image
            const emptyImg = new Image();
            emptyImg.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAUEBAAAACwAAAAAAQABAAACAkQBADs=';
            e.dataTransfer.setDragImage(emptyImg, 0, 0);
        }
        
        function updateDragGhostPosition(e) {
            if (dragGhost) {
                dragGhost.style.left = (e.clientX + 10) + 'px';
                dragGhost.style.top = (e.clientY - 20) + 'px';
            }
        }
        
        function removeDragGhost() {
            if (dragGhost) {
                dragGhost.remove();
                dragGhost = null;
            }
        }
        
        function highlightDropZones() {
            if (!draggedGuide) return;
            
            document.querySelectorAll('.day-slot').forEach(slot => {
                const dayElement = slot.closest('.calendar-day');
                if (dayElement && !dayElement.classList.contains('has-constraint') && !dayElement.classList.contains('other-month')) {
                    if (!slot.classList.contains('occupied')) {
                        slot.classList.add('drop-zone');
                    }
                } else {
                    slot.classList.add('drop-invalid');
                }
            });
        }
        
        function clearDropZoneHighlights() {
            document.querySelectorAll('.day-slot').forEach(slot => {
                slot.classList.remove('drop-zone', 'drop-invalid');
            });
        }
        
        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            // Update ghost position
            updateDragGhostPosition(e);
            
            // Highlight current drop target
            const slot = e.target.closest('.day-slot');
            if (slot) {
                clearTempHighlights();
                if (slot.classList.contains('drop-zone')) {
                    slot.style.transform = 'scale(1.05)';
                    slot.style.borderWidth = '3px';
                }
            }
        }
        
        function handleDragLeave(e) {
            // Clear temporary highlights
            clearTempHighlights();
        }
        
        function clearTempHighlights() {
            document.querySelectorAll('.day-slot').forEach(slot => {
                slot.style.transform = '';
                slot.style.borderWidth = '';
            });
        }
        
        async function handleDrop(e) {
            e.preventDefault();
            console.log('🎯 Drop');
            
            const slot = e.target.closest('.day-slot');
            const dayElement = e.target.closest('.calendar-day');
            
            if (!slot || !dayElement || !draggedGuide) {
                showNotification('שיבוץ לא חוקי', 'error');
                return;
            }
            
            const date = dayElement.dataset.date;
            const slotType = slot.dataset.slot;
            
            // Validate assignment
            try {
                const validation = await validateAssignment(draggedGuide.id, date, slotType);
                
                if (!validation.is_valid) {
                    showNotification(`שיבוץ נכשל: ${validation.reasons.join(', ')}`, 'error');
                    return;
                }
                
                if (validation.warnings.length > 0) {
                    showNotification(`אזהרה: ${validation.warnings.join(', ')}`, 'warning');
                }
                
                // Create assignment
                await createAssignment(draggedGuide.id, date, slotType);
                
                showNotification(`${draggedGuide.name} שובץ בהצלחה ל-${date}`, 'success');
                
            } catch (error) {
                console.error('Error in drop:', error);
                showNotification('שגיאה בביצוע השיבוץ', 'error');
            }
        }
        
        // Enhanced slot-specific drag handlers
        function handleSlotDragOver(e) {
            e.preventDefault();
            e.stopPropagation();
            
            if (!draggedGuide) return;
            
            const slot = e.currentTarget;
            const date = slot.dataset.date;
            const slotType = slot.dataset.slot;
            
            // Update drag effect based on validity
            if (slot.classList.contains('occupied')) {
                e.dataTransfer.dropEffect = 'none';
                slot.classList.add('drop-invalid');
            } else if (slot.classList.contains('drop-zone')) {
                e.dataTransfer.dropEffect = 'move';
                slot.classList.add('drop-hover');
            } else {
                e.dataTransfer.dropEffect = 'none';
                slot.classList.add('drop-invalid');
            }
            
            // Update ghost position
            updateDragGhostPosition(e);
        }
        
        function handleSlotDragEnter(e) {
            e.preventDefault();
            e.stopPropagation();
            
            if (!draggedGuide) return;
            
            const slot = e.currentTarget;
            
            // Add visual feedback for entering slot
            if (slot.classList.contains('drop-zone')) {
                slot.classList.add('drop-enter');
                slot.style.transform = 'scale(1.05)';
            }
        }
        
        function handleSlotDragLeave(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const slot = e.currentTarget;
            
            // Remove visual feedback when leaving slot
            slot.classList.remove('drop-hover', 'drop-enter', 'drop-invalid');
            slot.style.transform = '';
            
            // Only clear if we're actually leaving the slot (not moving to child element)
            if (!slot.contains(e.relatedTarget)) {
                clearSlotTempHighlights(slot);
            }
        }
        
        async function handleSlotDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const slot = e.currentTarget;
            const date = slot.dataset.date;
            const slotType = slot.dataset.slot;
            
            // Store a local reference to avoid timing issues with async operations
            const currentDraggedGuide = draggedGuide;
            
            console.log(`🎯 Slot drop: ${currentDraggedGuide?.name} -> ${date} (${slotType})`);
            
            if (!currentDraggedGuide) {
                console.error('Error: draggedGuide is null during drop operation');
                showNotification('שגיאה: לא נבחר מדריך', 'error');
                return;
            }
            
            // Clear visual feedback
            clearSlotTempHighlights(slot);
            
            // Check if slot is available
            if (slot.classList.contains('occupied')) {
                showNotification('המשבצת כבר תפוסה', 'error');
                return;
            }
            
            try {
                // Validate assignment
                const validation = await validateAssignment(currentDraggedGuide.id, date, slotType);
                
                if (!validation.is_valid) {
                    showNotification(`שיבוץ נכשל: ${validation.reasons.join(', ')}`, 'error');
                    slot.classList.add('drop-invalid');
                    setTimeout(() => slot.classList.remove('drop-invalid'), 1000);
                    return;
                }
                
                if (validation.warnings && validation.warnings.length > 0) {
                    showNotification(`אזהרה: ${validation.warnings.join(', ')}`, 'warning');
                }
                
                // Create assignment
                await createAssignmentWithGuide(currentDraggedGuide.id, date, slotType, currentDraggedGuide);
                
                // Show success feedback
                slot.classList.add('drop-success');
                setTimeout(() => slot.classList.remove('drop-success'), 1000);
                
                showNotification(`${currentDraggedGuide.name} שובץ בהצלחה ל-${formatDateForDisplay(date)} (${slotType === 'normal' ? 'רגיל' : 'חפיפה'})`, 'success');
                
                // Assignment display and statistics are updated by createAssignment function
                
            } catch (error) {
                console.error('Error in slot drop:', error);
                showNotification('שגיאה בביצוע השיבוץ', 'error');
                slot.classList.add('drop-invalid');
                setTimeout(() => slot.classList.remove('drop-invalid'), 1000);
            }
        }
        
        function handleSlotClick(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const slot = e.currentTarget;
            const date = slot.dataset.date;
            const slotType = slot.dataset.slot;
            
            // If there's a selected guide, try to assign them
            if (selectedGuide && !slot.classList.contains('occupied')) {
                createAssignmentByClick(selectedGuide.id, date, slotType);
            } else if (slot.classList.contains('occupied')) {
                // Show assignment details
                showAssignmentDetails(slot);
            } else {
                showNotification('אנא בחר מדריך תחילה', 'info');
            }
        }
        
        async function createAssignmentByClick(guideId, date, slotType) {
            try {
                const validation = await validateAssignment(guideId, date, slotType);
                
                if (!validation.is_valid) {
                    showNotification(`שיבוץ נכשל: ${validation.reasons.join(', ')}`, 'error');
                    return;
                }
                
                await createAssignment(guideId, date, slotType);
                showNotification(`שיבוץ בוצע בהצלחה`, 'success');
                
                await loadAssignments();
                await refreshGuideStatistics();
                
            } catch (error) {
                console.error('Error in click assignment:', error);
                showNotification('שגיאה בביצוע השיבוץ', 'error');
            }
        }
        
        function clearSlotTempHighlights(slot) {
            slot.classList.remove('drop-hover', 'drop-enter', 'drop-invalid', 'drop-success');
            slot.style.transform = '';
        }
        
        function cancelDragOperation() {
            console.log('🚫 Canceling drag operation');
            
            if (draggedGuide) {
                // Clear drag state
                clearDropZoneHighlights();
                clearTempHighlights();
                removeDragGhost();
                
                // Remove dragging class from all guide cards
                document.querySelectorAll('.guide-card').forEach(card => {
                    card.classList.remove('dragging');
                });
                
                draggedGuide = null;
                
                showNotification('פעולת הגרירה בוטלה', 'info');
            }
        }
        
        // Mobile Touch Support for Drag and Drop
        let touchStartPos = null;
        let touchCurrentElement = null;
        let isTouchDragging = false;
        
        function setupMobileTouchSupport() {
            // Add touch event listeners to guide cards and slots
            document.addEventListener('touchstart', handleTouchStart, { passive: false });
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd, { passive: false });
        }
        
        function handleTouchStart(e) {
            const guideCard = e.target.closest('.guide-card');
            if (guideCard && !guideCard.classList.contains('disabled')) {
                e.preventDefault();
                
                const touch = e.touches[0];
                touchStartPos = { x: touch.clientX, y: touch.clientY };
                touchCurrentElement = guideCard;
                
                // Get guide data
                const guideId = guideCard.dataset.guideId;
                const guide = guides.find(g => g.id == guideId);
                
                if (guide) {
                    // Start potential drag after short delay
                    setTimeout(() => {
                        if (touchCurrentElement && !isTouchDragging) {
                            startTouchDrag(guide, touch);
                        }
                    }, 200);
                }
            }
        }
        
        function handleTouchMove(e) {
            if (!touchStartPos || !touchCurrentElement) return;
            
            const touch = e.touches[0];
            const deltaX = Math.abs(touch.clientX - touchStartPos.x);
            const deltaY = Math.abs(touch.clientY - touchStartPos.y);
            
            // Start drag if moved more than 10px
            if ((deltaX > 10 || deltaY > 10) && !isTouchDragging) {
                const guideId = touchCurrentElement.dataset.guideId;
                const guide = guides.find(g => g.id == guideId);
                
                if (guide) {
                    startTouchDrag(guide, touch);
                }
            }
            
            if (isTouchDragging) {
                e.preventDefault();
                updateTouchDragPosition(touch);
                highlightTouchDropTarget(touch);
            }
        }
        
        function handleTouchEnd(e) {
            if (isTouchDragging) {
                e.preventDefault();
                const touch = e.changedTouches[0];
                performTouchDrop(touch);
            }
            
            // Clean up
            endTouchDrag();
        }
        
        function startTouchDrag(guide, touch) {
            console.log('📱 Starting touch drag:', guide.name);
            
            isTouchDragging = true;
            draggedGuide = guide;
            
            // Add visual feedback
            touchCurrentElement.classList.add('touch-dragging');
            
            // Create visual drag indicator
            createTouchDragGhost(guide, touch);
            
            // Highlight drop zones
            highlightDropZones();
            
            // Add haptic feedback if available
            if (navigator.vibrate) {
                navigator.vibrate(50);
            }
        }
        
        function createTouchDragGhost(guide, touch) {
            if (dragGhost) removeDragGhost();
            
            dragGhost = document.createElement('div');
            dragGhost.className = 'drag-ghost guide-card touch-ghost';
            dragGhost.innerHTML = `
                <div class="guide-name">${guide.name}</div>
                <div class="shift-counter">${guide.total_shifts || 0}</div>
                <div class="touch-indicator">📱</div>
            `;
            
            document.body.appendChild(dragGhost);
            updateTouchDragPosition(touch);
        }
        
        function updateTouchDragPosition(touch) {
            if (dragGhost) {
                dragGhost.style.left = (touch.clientX - 50) + 'px';
                dragGhost.style.top = (touch.clientY - 80) + 'px';
            }
        }
        
        function highlightTouchDropTarget(touch) {
            // Clear previous highlights
            document.querySelectorAll('.touch-drop-target').forEach(el => {
                el.classList.remove('touch-drop-target');
            });
            
            // Find element under touch
            const elementUnder = document.elementFromPoint(touch.clientX, touch.clientY);
            const slot = elementUnder?.closest('.day-slot');
            
            if (slot && slot.classList.contains('drop-zone')) {
                slot.classList.add('touch-drop-target');
                
                // Add haptic feedback for valid drop zone
                if (navigator.vibrate) {
                    navigator.vibrate(25);
                }
            }
        }
        
        async function performTouchDrop(touch) {
            const elementUnder = document.elementFromPoint(touch.clientX, touch.clientY);
            const slot = elementUnder?.closest('.day-slot');
            
            if (slot && draggedGuide) {
                const date = slot.dataset.date;
                const slotType = slot.dataset.slot;
                
                console.log(`📱 Touch drop: ${draggedGuide.name} -> ${date} (${slotType})`);
                
                if (slot.classList.contains('drop-zone')) {
                    try {
                        // Validate and create assignment
                        const validation = await validateAssignment(draggedGuide.id, date, slotType);
                        
                        if (!validation.is_valid) {
                            showNotification(`שיבוץ נכשל: ${validation.reasons.join(', ')}`, 'error');
                            // Add error haptic feedback
                            if (navigator.vibrate) {
                                navigator.vibrate([100, 50, 100]);
                            }
                            return;
                        }
                        
                        await createAssignment(draggedGuide.id, date, slotType);
                        
                        // Success feedback
                        slot.classList.add('drop-success');
                        setTimeout(() => slot.classList.remove('drop-success'), 1000);
                        
                        showNotification(`${draggedGuide.name} שובץ בהצלחה`, 'success');
                        
                        // Success haptic feedback
                        if (navigator.vibrate) {
                            navigator.vibrate([50, 25, 50]);
                        }
                        
                        // Refresh data
                        await loadAssignments();
                        await refreshGuideStatistics();
                        
                    } catch (error) {
                        console.error('Error in touch drop:', error);
                        showNotification('שגיאה בביצוע השיבוץ', 'error');
                        
                        // Error haptic feedback
                        if (navigator.vibrate) {
                            navigator.vibrate([200, 100, 200]);
                        }
                    }
                } else {
                    showNotification('שיבוץ לא חוקי', 'error');
                    
                    // Invalid drop haptic feedback
                    if (navigator.vibrate) {
                        navigator.vibrate([100, 50, 100]);
                    }
                }
            }
        }
        
        function endTouchDrag() {
            console.log('📱 Ending touch drag');
            
            isTouchDragging = false;
            touchStartPos = null;
            draggedGuide = null;
            
            // Clean up visual elements
            if (touchCurrentElement) {
                touchCurrentElement.classList.remove('touch-dragging');
                touchCurrentElement = null;
            }
            
            removeDragGhost();
            clearDropZoneHighlights();
            
            document.querySelectorAll('.touch-drop-target').forEach(el => {
                el.classList.remove('touch-drop-target');
            });
        }
        
        function formatDateForDisplay(dateStr) {
            const date = new Date(dateStr);
            return date.toLocaleDateString('he-IL', {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric'
            });
        }
        
        // Helper function to parse date string as local date (avoid UTC offset issues)
        function parseLocalDate(dateStr) {
            const [year, month, day] = dateStr.split('-').map(Number);
            return new Date(year, month - 1, day); // month is 0-indexed in Date constructor
        }
        
        // Helper function to format date as YYYY-MM-DD in local timezone
        function formatLocalDate(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }
        
        // Assignment management
        async function validateAssignment(guideId, date, slotType) {
            const response = await apiFetch('/api/enhanced-manual/validate-assignment', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    guide_id: guideId,
                    date: date,
                    slot_type: slotType
                })
            });
            
            return await response.json();
        }
        
        async function createAssignment(guideId, date, slotType) {
            return await createAssignmentWithGuide(guideId, date, slotType, null);
        }
        
        async function createAssignmentWithGuide(guideId, date, slotType, guideInfo) {
            const response = await apiFetch('/api/enhanced-manual/assign', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    guide_id: guideId,
                    date: date,
                    slot_type: slotType,
                    created_by: 'enhanced-manual'
                })
            });
            
            const result = await response.json();
            
            if (result.success) {
                // Use provided guide info or fallback to finding it
                const guide = guideInfo || draggedGuide || { name: getGuideNameById(guideId) };
                
                // Add to undo stack using new system
                addToUndoStack({
                    action: 'assign',
                    date: date,
                    slot_type: slotType,
                    guide_id: guideId,
                    guide_name: guide.name,
                    assignment: result.assignment
                });
                
                // Update UI
                updateSlotDisplay(date, slotType, guide);
                await refreshGuideStats();
                
                // Update constraints after assignment (for dynamic constraints)
                updateConstraintsAfterAssignment(guideId, date, slotType);
            } else {
                throw new Error(result.error);
            }
        }
        
        function updateSlotDisplay(date, slotType, guide) {
            const dayElement = document.querySelector(`[data-date="${date}"]`);
            if (!dayElement) return;
            
            const slot = dayElement.querySelector(`[data-slot="${slotType}"]`);
            if (!slot) return;
            
            slot.classList.remove('drop-zone');
            slot.classList.add(slotType === 'normal' ? 'occupied' : 'overlap-occupied');
            slot.innerHTML = `<span class="assigned-guide">${guide.name}</span>`;
        }
        
        async function refreshGuideStats() {
            await loadGuides();
            updateMonthlyStatistics();
        }
        
        // Phase 9: Real-time Statistics Implementation
        function updateMonthlyStatistics() {
            if (!guides || guides.length === 0) return;
            
            let totalShifts = 0;
            let totalSalaryFactor = 0;
            let shiftCounts = [];
            
            // Calculate totals from guide data
            guides.forEach(guide => {
                const shifts = guide.total_shifts || 0;
                const salaryFactor = guide.salary_factor || 0;
                
                totalShifts += shifts;
                totalSalaryFactor += salaryFactor;
                shiftCounts.push(shifts);
            });
            
            // Calculate averages and fairness
            const averageShifts = guides.length > 0 ? (totalShifts / guides.length).toFixed(1) : 0;
            const fairnessAssessment = calculateFairnessScore(shiftCounts);
            
            // Update UI elements if they exist
            const totalElement = document.getElementById('total-shifts-count');
            const averageElement = document.getElementById('average-shifts-count');
            const salaryElement = document.getElementById('total-salary-factor');
            
            if (totalElement) totalElement.textContent = totalShifts;
            if (averageElement) averageElement.textContent = averageShifts;
            if (salaryElement) salaryElement.textContent = totalSalaryFactor.toFixed(1);
            
            // Update fairness indicator
            updateFairnessIndicator(fairnessAssessment);
            
            // Update guide card visual indicators
            updateGuideCardFairnessIndicators(shiftCounts, totalShifts);
        }
        
        function calculateFairnessScore(shiftCounts) {
            if (shiftCounts.length === 0) return { score: 100, status: 'טוב', className: 'fairness-good' };
            
            const mean = shiftCounts.reduce((a, b) => a + b, 0) / shiftCounts.length;
            const variance = shiftCounts.reduce((sum, count) => sum + Math.pow(count - mean, 2), 0) / shiftCounts.length;
            const standardDeviation = Math.sqrt(variance);
            
            // Calculate fairness score (0-100, higher is better)
            const maxAcceptableDeviation = mean * 0.3; // 30% deviation is acceptable
            const score = Math.max(0, Math.min(100, 100 - (standardDeviation / maxAcceptableDeviation) * 100));
            
            let status, className;
            if (score >= 80) {
                status = 'טוב';
                className = 'fairness-good';
            } else if (score >= 60) {
                status = 'בינוני';
                className = 'fairness-warning';
            } else {
                status = 'דורש תשומת לב';
                className = 'fairness-poor';
            }
            
            return { score: Math.round(score), status, className };
        }
        
        function updateFairnessIndicator(fairness) {
            const statusElement = document.getElementById('fairness-status');
            if (!statusElement) return;
            
            statusElement.textContent = fairness.status;
            statusElement.classList.remove('fairness-good', 'fairness-warning', 'fairness-poor');
            statusElement.classList.add(fairness.className);
        }
        
        function updateGuideCardFairnessIndicators(shiftCounts, totalShifts) {
            if (totalShifts === 0 || !guides) return;
            
            const averageShifts = totalShifts / guides.length;
            
            guides.forEach(guide => {
                const guideCard = document.querySelector(`[data-guide-id="${guide.id}"]`);
                if (!guideCard) return;
                
                const guideShifts = guide.total_shifts || 0;
                const deviation = averageShifts > 0 ? ((guideShifts - averageShifts) / averageShifts) * 100 : 0;
                
                // Remove old fairness classes
                guideCard.classList.remove('overworked', 'underworked', 'balanced');
                
                // Add appropriate fairness class
                if (deviation > 25) {
                    guideCard.classList.add('overworked');
                } else if (deviation < -25) {
                    guideCard.classList.add('underworked');  
                } else {
                    guideCard.classList.add('balanced');
                }
            });
        }
        
        // Status and display updates
        function updateSelectedGuideDisplay() {
            const info = document.getElementById('selected-guide-info');
            if (selectedGuide) {
                info.textContent = `נבחר: ${selectedGuide.name}`;
            } else {
                info.textContent = 'לא נבחר מדריך';
            }
        }
        
        function updateGuidesInfo() {
            const info = document.getElementById('guides-info');
            info.textContent = `${guides.length} מדריכים זמינים`;
        }
        
        function updateConstraintsDisplay(constraintData) {
            const count = constraintData.total_count || 0;
            document.getElementById('constraints-count').textContent = `${count} אילוצים`;
        }
        
        // Statistics export functionality
        function exportMonthlyStatistics() {
            if (!guides || guides.length === 0) {
                showNotification('אין נתונים לייצוא', 'warning');
                return;
            }
            
            try {
                // Prepare CSV data
                const headers = [
                    'שם מדריך',
                    'סה״כ משמרות',
                    'משמרות רגילות',
                    'משמרות חפיפה',
                    'משמרות כונן',
                    'משמרות מוצ״ש',
                    'משמרות סוף שבוע',
                    'שעות שכר',
                    'יעילות (ש/משמרת)'
                ];
                
                const csvData = [headers.join(',')];
                
                // Add guide data
                guides.forEach(guide => {
                    const efficiency = guide.total_shifts > 0 ? 
                        (guide.salary_factor / guide.total_shifts).toFixed(2) : '0.00';
                        
                    const row = [
                        `"${guide.name}"`,
                        guide.total_shifts || 0,
                        guide.regular_shifts || 0,
                        guide.overlap_shifts || 0,
                        guide.conan_shifts || 0,
                        guide.motzash_shifts || 0,
                        guide.weekend_shifts || 0,
                        (guide.salary_factor || 0).toFixed(1),
                        efficiency
                    ];
                    csvData.push(row.join(','));
                });
                
                // Add summary row
                const totalShifts = guides.reduce((sum, g) => sum + (g.total_shifts || 0), 0);
                const totalSalaryFactor = guides.reduce((sum, g) => sum + (g.salary_factor || 0), 0);
                const avgEfficiency = totalShifts > 0 ? (totalSalaryFactor / totalShifts).toFixed(2) : '0.00';
                
                csvData.push(''); // Empty row
                csvData.push([
                    '"סיכום"',
                    totalShifts,
                    guides.reduce((sum, g) => sum + (g.regular_shifts || 0), 0),
                    guides.reduce((sum, g) => sum + (g.overlap_shifts || 0), 0),
                    guides.reduce((sum, g) => sum + (g.conan_shifts || 0), 0),
                    guides.reduce((sum, g) => sum + (g.motzash_shifts || 0), 0),
                    guides.reduce((sum, g) => sum + (g.weekend_shifts || 0), 0),
                    totalSalaryFactor.toFixed(1),
                    avgEfficiency
                ].join(','));
                
                // Create and download CSV file
                const csvContent = '\ufeff' + csvData.join('\n'); // Add BOM for Hebrew support
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                
                const monthName = new Date(currentYear, currentMonth - 1).toLocaleDateString('he-IL', { 
                    month: 'long', 
                    year: 'numeric' 
                });
                
                const fileName = `סטטיסטיקות_משמרות_${monthName.replace(/\s+/g, '_')}.csv`;
                
                if (link.download !== undefined) {
                    const url = URL.createObjectURL(blob);
                    link.setAttribute('href', url);
                    link.setAttribute('download', fileName);
                    link.style.visibility = 'hidden';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                    
                    showNotification(`קובץ CSV נוצר בהצלחה: ${fileName}`, 'success');
                } else {
                    throw new Error('הדפדפן לא תומך בהורדת קבצים');
                }
                
            } catch (error) {
                console.error('Export error:', error);
                showNotification('שגיאה בייצוא הנתונים', 'error');
            }
        }
        
        function updateStatus() {
            document.getElementById('last-updated').textContent = 
                new Date().toLocaleTimeString('he-IL');
        }
        
        // Legacy function - now redirects to new system
        function updateUndoButton() {
            updateUndoRedoButtons();
        }
        
        // Action button implementations
        function clearSelection() {
            clearGuideSelection();
        }
        
        async function saveChanges() {
            try {
                showNotification('שומר שינויים...', 'success');
                // Refresh data to ensure consistency
                await loadMonthData();
                showNotification('השינויים נשמרו בהצלחה', 'success');
            } catch (error) {
                console.error('Error saving changes:', error);
                showNotification('שגיאה בשמירת השינויים', 'error');
            }
        }
        
        // Enhanced Undo/Redo System
        function addToUndoStack(operation) {
            // Clear redo stack when new operation is added
            redoStack = [];
            
            // Add operation to undo stack
            undoStack.push({
                ...operation,
                timestamp: new Date().toISOString()
            });
            
            // Limit undo history size
            if (undoStack.length > MAX_UNDO_HISTORY) {
                undoStack.shift();
            }
            
            updateUndoRedoButtons();
        }
        
        async function undoLastAction() {
            if (undoStack.length === 0) return;
            
            const operation = undoStack.pop();
            
            try {
                const inverseOperation = await executeUndoOperation(operation);
                
                // Add inverse operation to redo stack
                if (inverseOperation) {
                    redoStack.push(inverseOperation);
                }
                
                showNotification('הפעולה בוטלה בהצלחה', 'success');
                updateUndoRedoButtons();
                
            } catch (error) {
                console.error('Error undoing operation:', error);
                showNotification('שגיאה בביטול הפעולה', 'error');
                // Put operation back if undo failed
                undoStack.push(operation);
                updateUndoRedoButtons();
            }
        }
        
        async function redoLastAction() {
            if (redoStack.length === 0) return;
            
            const operation = redoStack.pop();
            
            try {
                const inverseOperation = await executeRedoOperation(operation);
                
                // Add inverse operation back to undo stack
                if (inverseOperation) {
                    undoStack.push(inverseOperation);
                }
                
                showNotification('הפעולה בוצעה שוב בהצלחה', 'success');
                updateUndoRedoButtons();
                
            } catch (error) {
                console.error('Error redoing operation:', error);
                showNotification('שגיאה בביצוע הפעולה שוב', 'error');
                // Put operation back if redo failed
                redoStack.push(operation);
                updateUndoRedoButtons();
            }
        }
        
        async function executeUndoOperation(operation) {
            switch (operation.action) {
                case 'assign':
                    // Undo assignment by removing it
                    await removeAssignment(operation.date, operation.slot_type);
                    await refreshGuideStats();
                    
                    return {
                        action: 'remove',
                        date: operation.date,
                        slot_type: operation.slot_type,
                        guide_id: operation.guide_id,
                        guide_name: operation.guide_name || getGuideNameById(operation.guide_id)
                    };
                    
                case 'remove':
                    // Undo removal by re-creating assignment
                    await createAssignment(operation.guide_id, operation.date, operation.slot_type);
                    await refreshGuideStats();
                    
                    return {
                        action: 'assign',
                        date: operation.date,
                        slot_type: operation.slot_type,
                        guide_id: operation.guide_id,
                        guide_name: operation.guide_name
                    };
                    
                case 'replace':
                    // Undo replacement by restoring original assignment
                    await removeAssignment(operation.date, operation.slot_type);
                    if (operation.old_guide_id) {
                        await createAssignment(operation.old_guide_id, operation.date, operation.slot_type);
                    }
                    await refreshGuideStats();
                    
                    return {
                        action: 'replace',
                        date: operation.date,
                        slot_type: operation.slot_type,
                        old_guide_id: operation.new_guide_id,
                        old_guide_name: operation.new_guide_name,
                        new_guide_id: operation.old_guide_id,
                        new_guide_name: operation.old_guide_name
                    };
                    
                default:
                    console.warn('Unknown undo operation:', operation.action);
                    return null;
            }
        }
        
        async function executeRedoOperation(operation) {
            // Redo is essentially the reverse of undo
            return await executeUndoOperation(operation);
        }
        
        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');
            
            undoBtn.disabled = undoStack.length === 0;
            redoBtn.disabled = redoStack.length === 0;
            
            // Update tooltips with operation counts
            undoBtn.title = undoStack.length > 0 ? 
                `בטל פעולה (${undoStack.length} פעולות זמינות)` : 
                'אין פעולות לביטול';
                
            redoBtn.title = redoStack.length > 0 ? 
                `חזור על פעולה (${redoStack.length} פעולות זמינות)` : 
                'אין פעולות לחזרה';
        }
        
        function getGuideNameById(guideId) {
            const guide = guides.find(g => g.id == guideId);
            return guide ? guide.name : 'מדריך לא ידוע';
        }
        
        function clearUndoRedoHistory() {
            undoStack = [];
            redoStack = [];
            updateUndoRedoButtons();
        }
        
        function getUndoRedoHistorySummary() {
            return {
                undo: undoStack.map(op => ({
                    action: op.action,
                    guide: op.guide_name || getGuideNameById(op.guide_id),
                    date: formatDateForDisplay(op.date),
                    slot: op.slot_type === 'normal' ? 'רגיל' : 'חפיפה',
                    timestamp: op.timestamp
                })),
                redo: redoStack.map(op => ({
                    action: op.action,
                    guide: op.guide_name || getGuideNameById(op.guide_id),
                    date: formatDateForDisplay(op.date),
                    slot: op.slot_type === 'normal' ? 'רגיל' : 'חפיפה',
                    timestamp: op.timestamp
                }))
            };
        }
        
        async function removeAssignment(date, slotType) {
            try {
                const response = await apiFetch(`/api/enhanced-manual/assignment/${date}/${slotType}`, {
                    method: 'DELETE'
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // Update UI
                    const dayElement = document.querySelector(`[data-date="${date}"]`);
                    if (dayElement) {
                        const slot = dayElement.querySelector(`[data-slot="${slotType}"]`);
                        if (slot) {
                            slot.classList.remove('occupied', 'overlap-occupied');
                            slot.innerHTML = `<span class="slot-label">${slotType === 'normal' ? 'רגיל' : 'חפיפה'}</span>`;
                        }
                    }
                    
                    await refreshGuideStats();
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                console.error('Error removing assignment:', error);
                showNotification('שגיאה בהסרת השיבוץ', 'error');
            }
        }
        
        async function clearMonth() {
            const confirmed = await confirmClearMonth();
            if (!confirmed) {
                showNotification('ניקוי החודש בוטל', 'info');
                return;
            }
            
            try {
                showGlobalLoading('מנקה את החודש...', true);
                
                // Get all occupied slots
                const occupiedSlots = document.querySelectorAll('.calendar-slot.occupied');
                const totalSlots = occupiedSlots.length;
                
                if (totalSlots === 0) {
                    showNotification('אין שיבוצים למחיקה', 'info');
                    hideGlobalLoading();
                    return;
                }
                
                let clearedCount = 0;
                
                // Clear each slot with progress tracking
                for (const slot of occupiedSlots) {
                    const date = slot.dataset.date;
                    const slotType = slot.dataset.slot;
                    
                    try {
                        await removeAssignmentFromSlot(date, slotType, true); // Skip confirmation
                        clearedCount++;
                        
                        // Update progress
                        const progress = Math.round((clearedCount / totalSlots) * 100);
                        updateLoadingProgress(progress, `נוקה ${clearedCount} מתוך ${totalSlots} שיבוצים...`);
                        
                        // Small delay for visual feedback
                        await new Promise(resolve => setTimeout(resolve, 50));
                    } catch (error) {
                        console.error(`Error clearing slot ${date}:${slotType}:`, error);
                    }
                }
                
                updateLoadingProgress(100, 'הושלם!');
                setTimeout(() => {
                    hideGlobalLoading();
                    showNotification(`נוקו ${clearedCount} שיבוצים בהצלחה`, 'success');
                    refreshGuideStats();
                }, 500);
                
            } catch (error) {
                hideGlobalLoading();
                console.error('Error clearing month:', error);
                showNotification('שגיאה בניקוי החודש', 'error');
            }
        }
        
        async function importExistingSchedule() {
            try {
                showGlobalLoading('טוען שיבוץ קיים...', true);
                
                // Get current month and year
                const currentMonth = currentDate.getMonth() + 1;
                const currentYear = currentDate.getFullYear();
                
                // Fetch existing schedule from scheduler.html API
                const response = await fetch(`/api/schedule/${currentYear}/${currentMonth}`);
                if (!response.ok) {
                    throw new Error('Failed to fetch existing schedule');
                }
                
                const existingSchedule = await response.json();
                
                if (!existingSchedule || !existingSchedule.schedule || existingSchedule.schedule.length === 0) {
                    hideGlobalLoading();
                    showNotification('לא נמצא שיבוץ קיים לחודש זה', 'info');
                    return;
                }
                
                let importedCount = 0;
                const totalAssignments = existingSchedule.schedule.length;
                
                // Process each assignment
                for (let i = 0; i < existingSchedule.schedule.length; i++) {
                    const assignment = existingSchedule.schedule[i];
                    const progress = Math.floor((i / totalAssignments) * 100);
                    updateLoadingProgress(progress, `מייבא שיבוץ ${i + 1}/${totalAssignments}...`);
                    
                    try {
                        // Create assignment in enhanced manual scheduler
                        if (assignment.guide1_id) {
                            await createAssignment(assignment.guide1_id, assignment.date, 'normal');
                            importedCount++;
                        }
                        
                        if (assignment.guide2_id) {
                            await createAssignment(assignment.guide2_id, assignment.date, 'overlap');
                            importedCount++;
                        }
                    } catch (error) {
                        console.warn(`Failed to import assignment for ${assignment.date}:`, error);
                    }
                }
                
                updateLoadingProgress(100, 'הושלם!');
                setTimeout(() => {
                    hideGlobalLoading();
                    showNotification(`יובאו ${importedCount} שיבוצים בהצלחה`, 'success');
                    
                    // Refresh the display
                    loadMonthData();
                    refreshGuideStats();
                }, 500);
                
            } catch (error) {
                hideGlobalLoading();
                console.error('Error importing schedule:', error);
                showNotification('שגיאה בייבוא השיבוץ', 'error');
            }
        }
        
        function refreshData() {
            loadMonthData();
        }
        
        // Right-click Context Menu System
        let contextMenu = null;
        
        function createContextMenu() {
            if (contextMenu) return;
            
            contextMenu = document.createElement('div');
            contextMenu.className = 'context-menu';
            contextMenu.innerHTML = `
                <div class="context-menu-item" data-action="remove">
                    <span class="context-menu-icon">🗑️</span>
                    <span class="context-menu-text">הסר שיבוץ</span>
                </div>
                <div class="context-menu-item" data-action="swap">
                    <span class="context-menu-icon">🔄</span>
                    <span class="context-menu-text">החלף מדריך</span>
                </div>
                <div class="context-menu-item" data-action="copy">
                    <span class="context-menu-icon">📋</span>
                    <span class="context-menu-text">העתק שיבוץ</span>
                </div>
                <div class="context-menu-divider"></div>
                <div class="context-menu-item" data-action="details">
                    <span class="context-menu-icon">ℹ️</span>
                    <span class="context-menu-text">פרטי שיבוץ</span>
                </div>
                <div class="context-menu-item" data-action="history">
                    <span class="context-menu-icon">📜</span>
                    <span class="context-menu-text">היסטוריית שינויים</span>
                </div>
            `;
            
            document.body.appendChild(contextMenu);
            setupContextMenuEvents();
        }
        
        function setupContextMenuEvents() {
            // Handle context menu item clicks
            contextMenu.addEventListener('click', async (e) => {
                const item = e.target.closest('.context-menu-item');
                if (!item || !contextMenuTarget) return;
                
                const action = item.dataset.action;
                const slot = contextMenuTarget;
                const date = slot.dataset.date;
                const slotType = slot.dataset.slot;
                
                hideContextMenu();
                
                try {
                    switch (action) {
                        case 'remove':
                            await handleContextRemove(date, slotType, slot);
                            break;
                        case 'swap':
                            await handleContextSwap(date, slotType, slot);
                            break;
                        case 'copy':
                            handleContextCopy(date, slotType, slot);
                            break;
                        case 'details':
                            showAssignmentDetails(date, slotType, slot);
                            break;
                        case 'history':
                            showAssignmentHistory(date, slotType);
                            break;
                    }
                } catch (error) {
                    console.error('Context menu action error:', error);
                    showNotification('שגיאה בביצוע הפעולה', 'error');
                }
            });
            
            // Hide context menu when clicking outside
            document.addEventListener('click', (e) => {
                if (contextMenu && !contextMenu.contains(e.target)) {
                    hideContextMenu();
                }
            });
            
            // Hide context menu on escape
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && contextMenu && contextMenu.style.display !== 'none') {
                    hideContextMenu();
                }
            });
        }
        
        function showContextMenu(e, slot) {
            e.preventDefault();
            e.stopPropagation();
            
            if (!contextMenu) createContextMenu();
            
            contextMenuTarget = slot;
            
            // Check if slot has assignment
            const hasAssignment = slot.classList.contains('occupied') || slot.classList.contains('overlap-occupied');
            
            // Update menu items based on slot state
            updateContextMenuItems(hasAssignment, slot);
            
            // Position context menu
            const rect = slot.getBoundingClientRect();
            const menuWidth = 200;
            const menuHeight = 180;
            
            let x = e.clientX;
            let y = e.clientY;
            
            // Adjust position if menu would go off screen
            if (x + menuWidth > window.innerWidth) {
                x = window.innerWidth - menuWidth - 10;
            }
            if (y + menuHeight > window.innerHeight) {
                y = window.innerHeight - menuHeight - 10;
            }
            
            contextMenu.style.left = x + 'px';
            contextMenu.style.top = y + 'px';
            contextMenu.style.display = 'block';
            
            // Add visual highlight to target slot
            slot.classList.add('context-target');
        }
        
        function hideContextMenu() {
            if (contextMenu) {
                contextMenu.style.display = 'none';
            }
            
            // Remove highlight from target slot
            if (contextMenuTarget) {
                contextMenuTarget.classList.remove('context-target');
                contextMenuTarget = null;
            }
        }
        
        function updateContextMenuItems(hasAssignment, slot) {
            const items = contextMenu.querySelectorAll('.context-menu-item');
            
            items.forEach(item => {
                const action = item.dataset.action;
                
                switch (action) {
                    case 'remove':
                    case 'swap':
                    case 'details':
                    case 'history':
                        item.style.display = hasAssignment ? 'flex' : 'none';
                        break;
                    case 'copy':
                        item.style.display = hasAssignment ? 'flex' : 'none';
                        break;
                }
            });
            
            // Show/hide divider based on available items
            const divider = contextMenu.querySelector('.context-menu-divider');
            const hasVisibleItems = Array.from(items).some(item => 
                item.style.display !== 'none' && item.dataset.action !== 'details' && item.dataset.action !== 'history'
            );
            divider.style.display = hasVisibleItems && hasAssignment ? 'block' : 'none';
        }
        
        async function handleContextRemove(date, slotType, slot) {
            const assignedGuide = slot.querySelector('.assigned-guide');
            const guideName = assignedGuide ? assignedGuide.textContent : 'המדריך';
            
            const confirmed = confirm(`האם אתה בטוח שברצונך להסיר את השיבוץ של ${guideName} מ-${formatDateForDisplay(date)}?`);
            
            if (confirmed) {
                // Add to undo stack before removing
                const currentAssignment = await getCurrentAssignment(date, slotType);
                if (currentAssignment) {
                    undoStack.push({
                        action: 'remove',
                        date: date,
                        slot_type: slotType,
                        guide_id: currentAssignment.guide_id,
                        guide_name: currentAssignment.guide_name,
                        assignment: currentAssignment
                    });
                }
                
                await removeAssignment(date, slotType);
                showNotification(`השיבוץ של ${guideName} הוסר בהצלחה`, 'success');
                updateUndoButton();
            }
        }
        
        async function handleContextSwap(date, slotType, slot) {
            showNotification('פונקציית החלפה תהיה זמינה בגרסה הבאה', 'info');
            // TODO: Implement guide swapping functionality
        }
        
        function handleContextCopy(date, slotType, slot) {
            const assignedGuide = slot.querySelector('.assigned-guide');
            if (assignedGuide) {
                const guideName = assignedGuide.textContent;
                
                // Store in clipboard-like system
                copiedAssignment = {
                    guide_name: guideName,
                    slot_type: slotType,
                    date: date
                };
                
                showNotification(`שיבוץ של ${guideName} הועתק`, 'success');
            }
        }
        
        function showAssignmentDetails(date, slotType, slot) {
            const assignedGuide = slot.querySelector('.assigned-guide');
            if (!assignedGuide) return;
            
            const guideName = assignedGuide.textContent;
            const formattedDate = formatDateForDisplay(date);
            const slotLabel = slotType === 'normal' ? 'רגיל' : 'חפיפה';
            
            const details = `
פרטי השיבוץ:
מדריך: ${guideName}
תאריך: ${formattedDate}
סוג משמרת: ${slotLabel}
נוצר: ידנית
סטטוס: פעיל
            `.trim();
            
            alert(details);
        }
        
        function showAssignmentHistory(date, slotType) {
            showNotification('היסטוריית השינויים תהיה זמינה בגרסה הבאה', 'info');
            // TODO: Implement assignment history functionality
        }
        
        async function getCurrentAssignment(date, slotType) {
            try {
                // Get current assignment info for undo purposes
                const slot = document.querySelector(`[data-date="${date}"] [data-slot="${slotType}"]`);
                if (!slot) return null;
                
                const assignedGuide = slot.querySelector('.assigned-guide');
                if (!assignedGuide) return null;
                
                const guideName = assignedGuide.textContent;
                const guide = guides.find(g => g.name === guideName);
                
                return {
                    guide_id: guide ? guide.id : null,
                    guide_name: guideName,
                    date: date,
                    slot_type: slotType
                };
            } catch (error) {
                console.error('Error getting current assignment:', error);
                return null;
            }
        }
        
        // Assignment Conflict Resolution System
        let conflictDialog = null;
        
        function createConflictDialog() {
            if (conflictDialog) return;
            
            conflictDialog = document.createElement('div');
            conflictDialog.className = 'conflict-dialog-overlay';
            conflictDialog.innerHTML = `
                <div class="conflict-dialog">
                    <div class="conflict-header">
                        <h3>⚠️ זוהה קונפליקט בשיבוץ</h3>
                        <button class="conflict-close-btn">×</button>
                    </div>
                    <div class="conflict-content">
                        <div class="conflict-details"></div>
                        <div class="conflict-options">
                            <div class="conflict-option">
                                <input type="radio" id="conflict-replace" name="conflictAction" value="replace" checked>
                                <label for="conflict-replace">החלף את השיבוץ הקיים</label>
                            </div>
                            <div class="conflict-option">
                                <input type="radio" id="conflict-swap" name="conflictAction" value="swap">
                                <label for="conflict-swap">החלף מדריכים בין התאריכים</label>
                            </div>
                            <div class="conflict-option">
                                <input type="radio" id="conflict-cancel" name="conflictAction" value="cancel">
                                <label for="conflict-cancel">בטל את השיבוץ החדש</label>
                            </div>
                        </div>
                    </div>
                    <div class="conflict-actions">
                        <button class="btn btn-primary conflict-confirm">אשר</button>
                        <button class="btn btn-secondary conflict-cancel-btn">בטל</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(conflictDialog);
            setupConflictDialogEvents();
        }
        
        function setupConflictDialogEvents() {
            const closeBtn = conflictDialog.querySelector('.conflict-close-btn');
            const cancelBtn = conflictDialog.querySelector('.conflict-cancel-btn');
            const confirmBtn = conflictDialog.querySelector('.conflict-confirm');
            
            closeBtn.addEventListener('click', hideConflictDialog);
            cancelBtn.addEventListener('click', hideConflictDialog);
            
            confirmBtn.addEventListener('click', () => {
                const selectedAction = conflictDialog.querySelector('input[name="conflictAction"]:checked').value;
                resolveConflict(selectedAction);
            });
            
            // Close on overlay click
            conflictDialog.addEventListener('click', (e) => {
                if (e.target === conflictDialog) {
                    hideConflictDialog();
                }
            });
        }
        
        function showConflictDialog(conflictInfo) {
            if (!conflictDialog) createConflictDialog();
            
            const detailsElement = conflictDialog.querySelector('.conflict-details');
            detailsElement.innerHTML = `
                <div class="conflict-info">
                    <p><strong>מדריך חדש:</strong> ${conflictInfo.newGuide.name}</p>
                    <p><strong>תאריך:</strong> ${formatDateForDisplay(conflictInfo.date)}</p>
                    <p><strong>סוג משמרת:</strong> ${conflictInfo.slotType === 'normal' ? 'רגיל' : 'חפיפה'}</p>
                    ${conflictInfo.existingAssignment ? 
                        `<p><strong>שיבוץ קיים:</strong> ${conflictInfo.existingAssignment.guide_name}</p>` : 
                        ''
                    }
                    <div class="conflict-reasons">
                        <strong>סיבות הקונפליקט:</strong>
                        <ul>
                            ${conflictInfo.reasons.map(reason => `<li>${reason}</li>`).join('')}
                        </ul>
                    </div>
                </div>
            `;
            
            // Store conflict info for resolution
            conflictDialog.conflictInfo = conflictInfo;
            
            conflictDialog.style.display = 'flex';
        }
        
        function hideConflictDialog() {
            if (conflictDialog) {
                conflictDialog.style.display = 'none';
                conflictDialog.conflictInfo = null;
            }
        }
        
        async function resolveConflict(action) {
            const conflictInfo = conflictDialog.conflictInfo;
            if (!conflictInfo) return;
            
            hideConflictDialog();
            
            try {
                switch (action) {
                    case 'replace':
                        await handleConflictReplace(conflictInfo);
                        break;
                    case 'swap':
                        await handleConflictSwap(conflictInfo);
                        break;
                    case 'cancel':
                        showNotification('השיבוץ החדש בוטל', 'info');
                        break;
                }
            } catch (error) {
                console.error('Error resolving conflict:', error);
                showNotification('שגיאה בפתרון הקונפליקט', 'error');
            }
        }
        
        async function handleConflictReplace(conflictInfo) {
            const { date, slotType, newGuide, existingAssignment } = conflictInfo;
            
            // Add existing assignment to undo stack before replacing
            if (existingAssignment) {
                undoStack.push({
                    action: 'replace',
                    date: date,
                    slot_type: slotType,
                    old_guide_id: existingAssignment.guide_id,
                    old_guide_name: existingAssignment.guide_name,
                    new_guide_id: newGuide.id,
                    new_guide_name: newGuide.name
                });
            }
            
            // Remove existing assignment
            if (existingAssignment) {
                await removeAssignment(date, slotType);
            }
            
            // Create new assignment
            await createAssignment(newGuide.id, date, slotType);
            
            showNotification(`השיבוץ הוחלף בהצלחה: ${newGuide.name} ב-${formatDateForDisplay(date)}`, 'success');
            updateUndoButton();
        }
        
        async function handleConflictSwap(conflictInfo) {
            showNotification('פונקציית החלפת מדריכים תהיה זמינה בגרסה הבאה', 'info');
            // TODO: Implement guide swapping between dates
        }
        
        async function detectAssignmentConflicts(guideId, date, slotType) {
            const conflicts = [];
            const reasons = [];
            
            // Check if slot is already occupied
            const slot = document.querySelector(`[data-date="${date}"] [data-slot="${slotType}"]`);
            let existingAssignment = null;
            
            if (slot && (slot.classList.contains('occupied') || slot.classList.contains('overlap-occupied'))) {
                const assignedGuide = slot.querySelector('.assigned-guide');
                if (assignedGuide) {
                    const guideName = assignedGuide.textContent;
                    const guide = guides.find(g => g.name === guideName);
                    
                    existingAssignment = {
                        guide_id: guide ? guide.id : null,
                        guide_name: guideName,
                        date: date,
                        slot_type: slotType
                    };
                    
                    reasons.push(`המשבצת כבר תפוסה על ידי ${guideName}`);
                }
            }
            
            // Check for guide double-booking on same day
            const daySlots = document.querySelectorAll(`[data-date="${date}"] .day-slot`);
            let hasOtherAssignment = false;
            
            daySlots.forEach(daySlot => {
                if (daySlot.dataset.slot !== slotType) {
                    const assignedGuide = daySlot.querySelector('.assigned-guide');
                    if (assignedGuide) {
                        const assignedGuideName = assignedGuide.textContent;
                        const assignedGuideData = guides.find(g => g.name === assignedGuideName);
                        
                        if (assignedGuideData && assignedGuideData.id == guideId) {
                            hasOtherAssignment = true;
                            reasons.push(`המדריך כבר משובץ באותו יום במשמרת אחרת`);
                        }
                    }
                }
            });
            
            // Validate against constraints
            const guide = guides.find(g => g.id == guideId);
            if (guide) {
                const validation = await validateAssignment(guideId, date, slotType);
                
                if (!validation.is_valid) {
                    reasons.push(...validation.reasons);
                }
            }
            
            return {
                hasConflicts: reasons.length > 0,
                reasons: reasons,
                existingAssignment: existingAssignment,
                guide: guide
            };
        }
        
        // Bulk Operations System
        function toggleBulkMode() {
            bulkSelectionMode = !bulkSelectionMode;
            const panel = document.getElementById('bulk-operations-panel');
            const btn = document.getElementById('bulk-mode-btn');
            
            if (bulkSelectionMode) {
                panel.style.display = 'block';
                btn.classList.add('active');
                btn.innerHTML = '<span>📋</span> יצא ממצב בחירה';
                showNotification('מצב בחירה מרובה הופעל - לחץ על תאריכים לבחירה', 'info');
            } else {
                panel.style.display = 'none';
                btn.classList.remove('active');
                btn.innerHTML = '<span>📋</span> מצב בחירה מרובה';
                clearBulkSelection();
                showNotification('מצב בחירה מרובה הופסק', 'info');
            }
        }
        
        function setupBulkOperationListeners() {
            document.getElementById('bulk-close-btn').addEventListener('click', toggleBulkMode);
            document.getElementById('bulk-assign-btn').addEventListener('click', showBulkAssignSelector);
            document.getElementById('bulk-clear-btn').addEventListener('click', performBulkClear);
            document.getElementById('bulk-confirm-assign').addEventListener('click', performBulkAssign);
            document.getElementById('bulk-cancel-assign').addEventListener('click', hideBulkAssignSelector);
        }
        
        function handleDayClick(date, dayElement) {
            if (bulkSelectionMode) {
                if (selectedDates.has(date)) {
                    selectedDates.delete(date);
                    dayElement.classList.remove('bulk-selected');
                } else {
                    selectedDates.add(date);
                    dayElement.classList.add('bulk-selected');
                }
                updateBulkSelectionCount();
            }
        }
        
        function updateBulkSelectionCount() {
            const count = selectedDates.size;
            document.getElementById('selected-count').textContent = `${count} תאריכים נבחרו`;
            
            const buttons = document.querySelectorAll('.bulk-action-btn');
            buttons.forEach(btn => {
                btn.disabled = count === 0;
            });
        }
        
        function clearBulkSelection() {
            selectedDates.clear();
            document.querySelectorAll('.calendar-day.bulk-selected').forEach(day => {
                day.classList.remove('bulk-selected');
            });
            updateBulkSelectionCount();
        }
        
        function showBulkAssignSelector() {
            // Populate guide dropdown
            const select = document.getElementById('bulk-guide-select');
            select.innerHTML = '<option value="">-- בחר מדריך --</option>';
            guides.forEach(guide => {
                const option = document.createElement('option');
                option.value = guide.id;
                option.textContent = guide.name;
                select.appendChild(option);
            });
            
            document.getElementById('bulk-guide-selector').style.display = 'block';
        }
        
        function hideBulkAssignSelector() {
            document.getElementById('bulk-guide-selector').style.display = 'none';
        }
        
        async function performBulkAssign() {
            const guideId = document.getElementById('bulk-guide-select').value;
            const normalSlot = document.getElementById('bulk-normal-slot').checked;
            const overlapSlot = document.getElementById('bulk-overlap-slot').checked;
            
            if (!guideId || (!normalSlot && !overlapSlot)) {
                showNotification('בחר מדריך וסוג משמרת', 'error');
                return;
            }
            
            const guide = guides.find(g => g.id == guideId);
            if (!guide) return;
            
            const dates = Array.from(selectedDates);
            let successCount = 0;
            let errorCount = 0;
            
            bulkOperationInProgress = true;
            showNotification(`מבצע שיבוץ מרובה ל-${dates.length} תאריכים...`, 'info');
            
            for (const date of dates) {
                try {
                    if (normalSlot) {
                        await createAssignment(guideId, date, 'normal');
                        successCount++;
                    }
                    if (overlapSlot) {
                        await createAssignment(guideId, date, 'overlap');
                        successCount++;
                    }
                } catch (error) {
                    console.error(`Error assigning ${guide.name} to ${date}:`, error);
                    errorCount++;
                }
            }
            
            bulkOperationInProgress = false;
            hideBulkAssignSelector();
            clearBulkSelection();
            await refreshGuideStats();
            
            if (errorCount === 0) {
                showNotification(`שיבוץ מרובה הושלם בהצלחה: ${successCount} שיבוצים`, 'success');
            } else {
                showNotification(`שיבוץ מרובה הושלם חלקית: ${successCount} הצליחו, ${errorCount} נכשלו`, 'warning');
            }
        }
        
        async function performBulkClear() {
            if (!confirm('האם אתה בטוח שברצונך לנקות את כל השיבוצים מהתאריכים הנבחרים?')) {
                return;
            }
            
            const dates = Array.from(selectedDates);
            let successCount = 0;
            let errorCount = 0;
            
            bulkOperationInProgress = true;
            showNotification(`מנקה שיבוצים מ-${dates.length} תאריכים...`, 'info');
            
            for (const date of dates) {
                try {
                    await removeAssignment(date, 'normal');
                    await removeAssignment(date, 'overlap');
                    successCount++;
                } catch (error) {
                    console.error(`Error clearing assignments for ${date}:`, error);
                    errorCount++;
                }
            }
            
            bulkOperationInProgress = false;
            clearBulkSelection();
            await refreshGuideStats();
            
            if (errorCount === 0) {
                showNotification(`ניקוי מרובה הושלם בהצלחה: ${successCount} תאריכים נוקו`, 'success');
            } else {
                showNotification(`ניקוי מרובה הושלם חלקית: ${successCount} הצליחו, ${errorCount} נכשלו`, 'warning');
            }
        }
        
        async function loadAssignments() {
            try {
                console.log(`🔄 Loading assignments for ${currentYear}/${currentMonth}`);
                // Load existing assignments for the month
                const response = await apiFetch(`/api/schedule/${currentYear}/${currentMonth}`);
                const data = await response.json();
                
                console.log('📊 Loaded assignments data:', data);
                assignments = data || [];
                console.log('📋 Assignments array:', assignments);
                renderExistingAssignments();
            } catch (error) {
                console.error('Error loading assignments:', error);
            }
        }
        
        function renderExistingAssignments() {
            console.log('🎯 renderExistingAssignments called with assignments:', assignments);
            
            // Clear existing assignments display
            document.querySelectorAll('.day-slot').forEach(slot => {
                slot.classList.remove('occupied');
                const placeholder = slot.querySelector('.assignment-placeholder');
                if (placeholder) {
                    placeholder.textContent = 'לחץ כאן לשיבוץ';
                    placeholder.style.display = 'block';
                }
                
                const assignmentDisplay = slot.querySelector('.assignment-display');
                if (assignmentDisplay) {
                    assignmentDisplay.remove();
                }
            });
            
            // Display current assignments
            assignments.forEach(assignment => {
                console.log('🔍 Processing assignment:', assignment);
                // Use date_str for proper date formatting (avoids timezone issues)
                const displayDate = assignment.date_str || assignment.date.split('T')[0];
                
                if (assignment.guide1_id) {
                    const guide = guides.find(g => g.id === assignment.guide1_id);
                    updateSlotDisplayForLoadedAssignments(displayDate, 'normal', {
                        id: assignment.guide1_id,
                        name: guide?.name || assignment.guide1_name || `מדריך ${assignment.guide1_id}`,
                        role: assignment.guide1_role || 'רגיל'
                    });
                }
                if (assignment.guide2_id) {
                    const guide = guides.find(g => g.id === assignment.guide2_id);
                    updateSlotDisplayForLoadedAssignments(displayDate, 'overlap', {
                        id: assignment.guide2_id,
                        name: guide?.name || assignment.guide2_name || `מדריך ${assignment.guide2_id}`,
                        role: assignment.guide2_role || 'חפיפה'
                    });
                }
            });
        }
        
        function updateSlotDisplayForLoadedAssignments(date, slotType, guide) {
            console.log(`🎯 updateSlotDisplayForLoadedAssignments: looking for slot with date="${date}" slot="${slotType}" for guide=${guide.name}`);
            const slot = document.querySelector(`[data-date="${date}"][data-slot="${slotType}"]`);
            console.log('🔍 Found slot:', slot);
            if (!slot) {
                console.warn(`❌ Slot not found for date="${date}" slot="${slotType}"`);
                return;
            }
            
            // Mark slot as occupied
            slot.classList.add('occupied');
            
            // Use simple innerHTML approach like the main updateSlotDisplay function
            slot.classList.remove('drop-zone');
            slot.innerHTML = `<span class="assigned-guide">${guide.name}</span>`;
            
            console.log(`✅ Successfully updated slot for ${guide.name}`);
        }
        
        function showAssignmentDetails(slot) {
            const date = slot.dataset.date;
            const slotType = slot.dataset.slot;
            
            // Find assignment for this slot
            const assignment = assignments.find(a => a.date === date);
            if (!assignment) return;
            
            const guideId = slotType === 'normal' ? assignment.guide1_id : assignment.guide2_id;
            const guideName = slotType === 'normal' ? assignment.guide1_name : assignment.guide2_name;
            const guideRole = slotType === 'normal' ? assignment.guide1_role : assignment.guide2_role;
            
            if (!guideId) return;
            
            // Show assignment details in notification
            const formattedDate = formatDateForDisplay(date);
            showNotification(`
                שיבוץ: ${guideName} <br>
                תאריך: ${formattedDate} <br>
                סוג: ${slotType === 'normal' ? 'רגיל' : 'חפיפה'} <br>
                תפקיד: ${guideRole}
            `, 'info', 3000);
        }
        
        function updateDayStats(date) {
            const dayElement = document.querySelector(`[data-date="${date}"]`);
            if (!dayElement) return;
            
            const slots = dayElement.querySelectorAll('.day-slot.occupied');
            const shiftCount = slots.length;
            
            const statsElement = dayElement.querySelector('.shift-count');
            if (statsElement) {
                statsElement.textContent = shiftCount;
            }
        }
        
        async function refreshGuideStatistics() {
            try {
                // Reload guides with updated statistics
                await loadGuides();
                
                // Update guide cards display
                renderGuideCards();
                
                // Update status
                updateStatus();
                
            } catch (error) {
                console.error('Error refreshing guide statistics:', error);
            }
        }
        
        function handleKeyboardShortcuts(e) {
            // Ignore shortcuts when user is typing in input fields
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) {
                return;
            }
            
            switch(e.key) {
                case 'Escape':
                    e.preventDefault();
                    if (draggedGuide) {
                        // Cancel drag operation
                        cancelDragOperation();
                        showNotification('פעולת גרירה בוטלה', 'info');
                    } else if (selectedGuide) {
                        clearGuideSelection();
                        showNotification('בחירת מדריך בוטלה', 'info');
                    } else if (bulkModeActive) {
                        toggleBulkMode();
                        showNotification('מצב בחירה מרובה בוטל', 'info');
                    }
                    break;
                    
                case 'Delete':
                case 'Backspace':
                    e.preventDefault();
                    if (selectedCalendarSlot && selectedCalendarSlot.classList.contains('occupied')) {
                        // Remove assignment from selected calendar slot
                        const date = selectedCalendarSlot.dataset.date;
                        const slotType = selectedCalendarSlot.dataset.slot;
                        if (date && slotType) {
                            removeAssignmentFromSlot(date, slotType);
                        }
                    }
                    break;
                    
                case 'z':
                case 'Z':
                    if (e.ctrlKey && !e.shiftKey) {
                        e.preventDefault();
                        undoLastAction();
                    } else if (e.ctrlKey && e.shiftKey) {
                        e.preventDefault();
                        redoLastAction();
                    }
                    break;
                    
                case 'y':
                case 'Y':
                    if (e.ctrlKey) {
                        e.preventDefault();
                        redoLastAction();
                    }
                    break;
                    
                case 's':
                case 'S':
                    if (e.ctrlKey) {
                        e.preventDefault();
                        saveChanges();
                    }
                    break;
                    
                case 'r':
                case 'R':
                    if (e.ctrlKey) {
                        e.preventDefault();
                        refreshData();
                    }
                    break;
                    
                case 'b':
                case 'B':
                    if (e.ctrlKey) {
                        e.preventDefault();
                        toggleBulkMode();
                    }
                    break;
                    
                case 'ArrowLeft':
                    if (e.ctrlKey) {
                        e.preventDefault();
                        navigateMonth(-1);
                    }
                    break;
                    
                case 'ArrowRight':
                    if (e.ctrlKey) {
                        e.preventDefault();
                        navigateMonth(1);
                    }
                    break;
                    
                case 'F1':
                    e.preventDefault();
                    showKeyboardShortcutsHelp();
                    break;
            }
        }
        
        // Show keyboard shortcuts help
        function showKeyboardShortcutsHelp() {
            const helpMessage = `
⌨️ קיצורי מקלדת זמינים:

🔄 ניווט:
• Ctrl + ← / → - חודש קודם/הבא
• F1 - הצג עזרה זו

✂️ עריכה:
• Escape - בטל פעולה נוכחית
• Delete/Backspace - הסר שיבוץ נבחר
• Ctrl + Z - בטל פעולה אחרונה
• Ctrl + Shift + Z / Ctrl + Y - חזור על פעולה

💾 שמירה:
• Ctrl + S - שמור שינויים
• Ctrl + R - רענן נתונים

🎯 מצבי עבודה:
• Ctrl + B - מצב בחירה מרובה
            `.trim();
            
            showNotification(helpMessage, 'info', 8000);
        }
        
        // Enhanced Tutorial and Tooltip System
        class TutorialSystem {
            constructor() {
                this.currentStep = 0;
                this.steps = [
                    {
                        target: '.guides-container',
                        title: 'כרטיסי המדריכים',
                        content: 'כאן תראו את כל המדריכים הזמינים. גררו מדריך לתאריך כדי לשבץ אותו.',
                        position: 'bottom'
                    },
                    {
                        target: '.calendar-grid',
                        title: 'לוח השיבוץ',
                        content: 'כל יום מחולק ל-2 משמרות: רגילה וחפיפה. גררו מדריכים לתאריכים הרצויים.',
                        position: 'top'
                    },
                    {
                        target: '.action-buttons',
                        title: 'כפתורי פעולה',
                        content: 'כאן תמצאו כפתורים לשמירת שינויים, ביטול פעולות ומצב בחירה מרובה.',
                        position: 'bottom'
                    },
                    {
                        target: '.statistics-panel',
                        title: 'סטטיסטיקות',
                        content: 'עקבו אחר מספר המשמרות של כל מדריך ויחס שיבוץ הוגן.',
                        position: 'top'
                    },
                    {
                        target: '.calendar-legend',
                        title: 'מקרא צבעים',
                        content: 'השתמשו במקרא להבנת המשמעות של צבעים שונים בלוח השיבוץ.',
                        position: 'bottom'
                    }
                ];
                this.init();
            }

            init() {
                const helpBtn = document.getElementById('help-btn');
                const helpOverlay = document.getElementById('help-overlay');
                const helpClose = document.getElementById('help-close');
                const helpPrev = document.getElementById('help-prev');
                const helpNext = document.getElementById('help-next');

                helpBtn?.addEventListener('click', () => this.startTutorial());
                helpClose?.addEventListener('click', () => this.closeTutorial());
                helpPrev?.addEventListener('click', () => this.previousStep());
                helpNext?.addEventListener('click', () => this.nextStep());

                // Initialize tooltips for existing elements
                this.initTooltips();
            }

            startTutorial() {
                this.currentStep = 0;
                document.getElementById('help-overlay').style.display = 'block';
                this.showStep();
            }

            closeTutorial() {
                document.getElementById('help-overlay').style.display = 'none';
                this.clearHighlights();
            }

            showStep() {
                const step = this.steps[this.currentStep];
                const helpStep = document.getElementById('help-step');
                const helpCurrentStep = document.getElementById('help-current-step');
                const helpTotalSteps = document.getElementById('help-total-steps');
                const helpPrev = document.getElementById('help-prev');
                const helpNext = document.getElementById('help-next');

                // Update content
                helpStep.querySelector('h4').textContent = step.title;
                helpStep.querySelector('p').textContent = step.content;
                helpCurrentStep.textContent = this.currentStep + 1;
                helpTotalSteps.textContent = this.steps.length;

                // Update button states
                helpPrev.disabled = this.currentStep === 0;
                helpNext.disabled = this.currentStep === this.steps.length - 1;
                helpNext.textContent = this.currentStep === this.steps.length - 1 ? 'סיום' : 'הבא';

                // Position step dialog
                this.positionStep(step);

                // Highlight target
                this.highlightTarget(step.target);
            }

            positionStep(step) {
                const helpStep = document.getElementById('help-step');
                const target = document.querySelector(step.target);
                
                if (target) {
                    const rect = target.getBoundingClientRect();
                    const stepHeight = helpStep.offsetHeight;
                    const stepWidth = helpStep.offsetWidth;
                    
                    let top, left;
                    
                    if (step.position === 'bottom') {
                        top = rect.bottom + 20;
                        left = rect.left + (rect.width / 2) - (stepWidth / 2);
                    } else {
                        top = rect.top - stepHeight - 20;
                        left = rect.left + (rect.width / 2) - (stepWidth / 2);
                    }
                    
                    // Ensure step stays within viewport
                    const maxLeft = window.innerWidth - stepWidth - 20;
                    const maxTop = window.innerHeight - stepHeight - 20;
                    
                    left = Math.max(20, Math.min(left, maxLeft));
                    top = Math.max(20, Math.min(top, maxTop));
                    
                    helpStep.style.left = left + 'px';
                    helpStep.style.top = top + 'px';
                }
            }

            highlightTarget(selector) {
                this.clearHighlights();
                const target = document.querySelector(selector);
                if (target) {
                    target.classList.add('guide-tutorial-highlight');
                    target.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }

            clearHighlights() {
                document.querySelectorAll('.guide-tutorial-highlight')
                    .forEach(el => el.classList.remove('guide-tutorial-highlight'));
            }

            previousStep() {
                if (this.currentStep > 0) {
                    this.currentStep--;
                    this.showStep();
                }
            }

            nextStep() {
                if (this.currentStep < this.steps.length - 1) {
                    this.currentStep++;
                    this.showStep();
                } else {
                    this.closeTutorial();
                }
            }

            initTooltips() {
                // Enhanced tooltip functionality for all elements with title attribute
                document.addEventListener('mouseover', (e) => {
                    if (e.target.title || e.target.getAttribute('data-tooltip')) {
                        this.showTooltip(e.target, e.target.title || e.target.getAttribute('data-tooltip'));
                    }
                });

                document.addEventListener('mouseout', (e) => {
                    if (e.target.title || e.target.getAttribute('data-tooltip') || e.target.getAttribute('data-original-title')) {
                        this.hideTooltip();
                    }
                });
                
                // Additional event listeners to ensure tooltip is always hidden
                document.addEventListener('mouseleave', () => {
                    this.hideTooltip();
                });
                
                document.addEventListener('scroll', () => {
                    this.hideTooltip();
                });

                document.addEventListener('mousemove', (e) => {
                    const tooltip = document.getElementById('tooltip');
                    if (tooltip.classList.contains('show')) {
                        tooltip.style.left = (e.pageX + 10) + 'px';
                        tooltip.style.top = (e.pageY - 30) + 'px';
                    }
                });
            }

            showTooltip(element, text) {
                const tooltip = document.getElementById('tooltip');
                tooltip.textContent = text;
                tooltip.classList.add('show');
                
                // Remove title to prevent browser tooltip
                if (element.title) {
                    element.setAttribute('data-original-title', element.title);
                    element.removeAttribute('title');
                }
            }

            hideTooltip() {
                const tooltip = document.getElementById('tooltip');
                if (tooltip) {
                    tooltip.classList.remove('show');
                    tooltip.textContent = ''; // Clear tooltip content
                }
                
                // Restore original title
                document.querySelectorAll('[data-original-title]').forEach(el => {
                    el.title = el.getAttribute('data-original-title');
                    el.removeAttribute('data-original-title');
                });
            }
        }

        // Enhanced Help System with Detailed Documentation
        function showDetailedHelp() {
            const detailedHelp = document.createElement('div');
            detailedHelp.className = 'detailed-help-modal';
            detailedHelp.innerHTML = `
                <div class="help-modal-content">
                    <div class="help-modal-header">
                        <h2>📖 מדריך מפורט למערכת השיבוץ המשופרת</h2>
                        <button class="help-modal-close" onclick="closeDetailedHelp()">&times;</button>
                    </div>
                    <div class="help-modal-body">
                        <div class="help-sections">
                            <div class="help-section">
                                <h3>🎯 איך להתחיל</h3>
                                <ol>
                                    <li>בחרו חודש ושנה באמצעות כפתורי הניווט</li>
                                    <li>המערכת תטען אוטומטית את המדריכים והאילוצים</li>
                                    <li>גררו מדריכים מהרשימה לתאריכים בלוח</li>
                                    <li>שמרו את השינויים בלחיצה על "שמור שינויים"</li>
                                </ol>
                            </div>

                            <div class="help-section">
                                <h3>🖱️ פעולות גרירה ושחרור</h3>
                                <ul>
                                    <li><strong>גרירת מדריך לתאריך:</strong> יוצר שיבוץ חדש</li>
                                    <li><strong>גרירה לסלוט רגיל:</strong> משמרת רגילה (מקדם ×1.0)</li>
                                    <li><strong>גרירה לסלוט חפיפה:</strong> משמרת חפיפה (מקדם ×1.0)</li>
                                    <li><strong>גרירה לסוף שבוע:</strong> מקדם ×2.0 לשבת</li>
                                    <li><strong>גרירה למשמרת לילה:</strong> מקדם ×1.5</li>
                                </ul>
                            </div>

                            <div class="help-section">
                                <h3>⚠️ מערכת האילוצים</h3>
                                <ul>
                                    <li><strong>🚫 אילוץ רגיל:</strong> המדריך הגדיר שהוא לא זמין בתאריך</li>
                                    <li><strong>📅 אילוץ קבוע:</strong> אילוץ שבועי קבוע (כל יום ראשון למשל)</li>
                                    <li><strong>🌴 חופשה:</strong> תקופת חופשה שהוגדרה מראש</li>
                                    <li><strong>⚠️ אילוץ דינמי:</strong> נוצר אוטומטית כדי למנוע ימים עוקבים</li>
                                </ul>
                            </div>

                            <div class="help-section">
                                <h3>📋 מצב בחירה מרובה</h3>
                                <ol>
                                    <li>לחצו על "מצב בחירה מרובה" או Ctrl+B</li>
                                    <li>לחצו על תאריכים לבחירתם (יסומנו בכחול)</li>
                                    <li>בחרו מדריך לשיבוץ מהרשימה הנפתחת</li>
                                    <li>בחרו סוג משמרת (רגיל/חפיפה)</li>
                                    <li>לחצו "אשר שיבוץ" להשלמת הפעולה</li>
                                </ol>
                            </div>

                            <div class="help-section">
                                <h3>📊 הבנת הסטטיסטיקות</h3>
                                <ul>
                                    <li><strong>מספר משמרות:</strong> כמות השיבוצים של כל מדריך</li>
                                    <li><strong>שעות שכר:</strong> סך השעות המשוקללות לפי מקדמים</li>
                                    <li><strong>מאזן הוגן:</strong> ירוק = טוב, כתום = בינוני, אדום = לא הוגן</li>
                                    <li><strong>ממוצע חודשי:</strong> ממוצע משמרות לכל מדריך</li>
                                </ul>
                            </div>

                            <div class="help-section">
                                <h3>🛠️ פתרון בעיות נפוצות</h3>
                                <ul>
                                    <li><strong>לא ניתן לגרור מדריך:</strong> בדקו שהוא לא נבחר במצב "צפייה באילוצים"</li>
                                    <li><strong>התאריך מסומן באדום:</strong> קיים אילוץ המונע את השיבוץ</li>
                                    <li><strong>השינויים לא נשמרים:</strong> בדקו את החיבור לאינטרנט</li>
                                    <li><strong>הסטטיסטיקות לא מתעדכנות:</strong> לחצו על כפתור הרענון</li>
                                </ul>
                            </div>

                            <div class="help-section">
                                <h3>⌨️ קיצורי מקלדת מתקדמים</h3>
                                <ul>
                                    <li><strong>Ctrl + S:</strong> שמירה מהירה</li>
                                    <li><strong>Ctrl + Z:</strong> ביטול פעולה אחרונה</li>
                                    <li><strong>Ctrl + Y:</strong> חזרה על פעולה</li>
                                    <li><strong>Delete:</strong> מחיקת שיבוץ נבחר</li>
                                    <li><strong>Escape:</strong> ביטול פעולה נוכחית</li>
                                    <li><strong>F1:</strong> עזרה מהירה</li>
                                </ul>
                            </div>

                            <div class="help-section">
                                <h3>💡 טיפים מתקדמים</h3>
                                <ul>
                                    <li><strong>שיבוץ מהיר:</strong> השתמשו במצב בחירה מרובה לשיבוץ חוזר</li>
                                    <li><strong>צפייה באילוצים:</strong> לחצו על מדריך לראות את כל האילוצים שלו</li>
                                    <li><strong>ייצוא נתונים:</strong> לחצו על כפתור הייצוא בסטטיסטיקות</li>
                                    <li><strong>שמירה אוטומטית:</strong> המערכת שומרת אוטומטית כל 30 שניות</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(detailedHelp);
        }

        function closeDetailedHelp() {
            const modal = document.querySelector('.detailed-help-modal');
            if (modal) {
                modal.remove();
            }
        }

        // Keyboard Navigation Helper Functions
        function navigateGuideCards(currentCard, direction) {
            const allCards = Array.from(document.querySelectorAll('.guide-card'));
            const currentIndex = allCards.indexOf(currentCard);
            const nextIndex = currentIndex + direction;
            
            if (nextIndex >= 0 && nextIndex < allCards.length) {
                allCards[nextIndex].focus();
            } else if (direction > 0 && nextIndex >= allCards.length) {
                // Wrap to first card
                allCards[0].focus();
            } else if (direction < 0 && nextIndex < 0) {
                // Wrap to last card
                allCards[allCards.length - 1].focus();
            }
        }

        function focusFirstGuideCard() {
            const firstCard = document.querySelector('.guide-card');
            if (firstCard) {
                firstCard.focus();
            }
        }

        function focusLastGuideCard() {
            const cards = document.querySelectorAll('.guide-card');
            if (cards.length > 0) {
                cards[cards.length - 1].focus();
            }
        }

        // Enhanced accessibility announcements
        function announceToScreenReader(message) {
            const announcement = document.createElement('div');
            announcement.setAttribute('aria-live', 'polite');
            announcement.setAttribute('aria-atomic', 'true');
            announcement.className = 'sr-only';
            announcement.textContent = message;
            
            document.body.appendChild(announcement);
            
            // Remove after announcement
            setTimeout(() => {
                document.body.removeChild(announcement);
            }, 1000);
        }

        // Performance Optimization Utilities
        class PerformanceManager {
            constructor() {
                this.debounceTimers = new Map();
                this.frameCallbacks = new Set();
                this.isAnimating = false;
            }

            // Debounce function for API calls
            debounce(key, func, delay = 300) {
                if (this.debounceTimers.has(key)) {
                    clearTimeout(this.debounceTimers.get(key));
                }
                
                const timer = setTimeout(() => {
                    func();
                    this.debounceTimers.delete(key);
                }, delay);
                
                this.debounceTimers.set(key, timer);
            }

            // Throttle function for scroll/resize events
            throttle(func, delay = 16) {
                let lastCall = 0;
                return function(...args) {
                    const now = Date.now();
                    if (now - lastCall >= delay) {
                        lastCall = now;
                        func.apply(this, args);
                    }
                };
            }

            // Batch DOM updates using requestAnimationFrame
            batchDOMUpdate(callback) {
                this.frameCallbacks.add(callback);
                
                if (!this.isAnimating) {
                    this.isAnimating = true;
                    requestAnimationFrame(() => {
                        this.frameCallbacks.forEach(cb => cb());
                        this.frameCallbacks.clear();
                        this.isAnimating = false;
                    });
                }
            }

            // Lazy loading for off-screen elements
            observeElement(element, callback) {
                if ('IntersectionObserver' in window) {
                    const observer = new IntersectionObserver((entries) => {
                        entries.forEach(entry => {
                            if (entry.isIntersecting) {
                                callback(entry.target);
                                observer.unobserve(entry.target);
                            }
                        });
                    }, { threshold: 0.1 });
                    
                    observer.observe(element);
                } else {
                    // Fallback for older browsers
                    callback(element);
                }
            }

            // Memory cleanup
            cleanup() {
                this.debounceTimers.forEach(timer => clearTimeout(timer));
                this.debounceTimers.clear();
                this.frameCallbacks.clear();
            }
        }

        // Initialize performance manager
        const performanceManager = new PerformanceManager();

        // Error Logging and Debugging System
        class DebugManager {
            constructor() {
                this.logs = [];
                this.maxLogs = 100;
                this.debugLevel = 'info'; // 'debug', 'info', 'warn', 'error'
                this.enableConsoleOutput = true;
                this.enableRemoteLogging = false;
                
                // Initialize error tracking
                this.initErrorTracking();
            }

            initErrorTracking() {
                // Global error handler
                window.addEventListener('error', (event) => {
                    this.error('JavaScript Error', {
                        message: event.message,
                        filename: event.filename,
                        line: event.lineno,
                        column: event.colno,
                        stack: event.error?.stack
                    });
                });

                // Promise rejection handler
                window.addEventListener('unhandledrejection', (event) => {
                    this.error('Unhandled Promise Rejection', {
                        reason: event.reason,
                        promise: event.promise
                    });
                });
            }

            log(level, category, data = {}) {
                const timestamp = new Date().toISOString();
                const logEntry = {
                    timestamp,
                    level,
                    category,
                    data,
                    userAgent: navigator.userAgent,
                    url: window.location.href
                };

                // Add to logs array
                this.logs.push(logEntry);
                
                // Maintain max logs limit
                if (this.logs.length > this.maxLogs) {
                    this.logs.shift();
                }

                // Console output
                if (this.enableConsoleOutput) {
                    const prefix = `[${timestamp}] [${level.toUpperCase()}] ${category}:`;
                    switch (level) {
                        case 'debug':
                            console.debug(prefix, data);
                            break;
                        case 'info':
                            console.info(prefix, data);
                            break;
                        case 'warn':
                            console.warn(prefix, data);
                            break;
                        case 'error':
                            console.error(prefix, data);
                            break;
                    }
                }

                // Remote logging (if enabled)
                if (this.enableRemoteLogging && level === 'error') {
                    this.sendToRemote(logEntry);
                }
            }

            debug(category, data) {
                this.log('debug', category, data);
            }

            info(category, data) {
                this.log('info', category, data);
            }

            warn(category, data) {
                this.log('warn', category, data);
            }

            error(category, data) {
                this.log('error', category, data);
            }

            // Performance tracking
            trackPerformance(operation, duration) {
                this.info('Performance', {
                    operation,
                    duration,
                    timestamp: Date.now()
                });
            }

            // API call tracking
            trackAPICall(url, method, status, duration) {
                this.info('API Call', {
                    url,
                    method,
                    status,
                    duration
                });
            }

            // User action tracking
            trackUserAction(action, details = {}) {
                this.info('User Action', {
                    action,
                    details,
                    timestamp: Date.now()
                });
            }

            // Export logs for debugging
            exportLogs() {
                const logsJson = JSON.stringify(this.logs, null, 2);
                const blob = new Blob([logsJson], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `enhanced-scheduler-logs-${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                
                URL.revokeObjectURL(url);
            }

            // Show debug console
            showDebugConsole() {
                const existing = document.getElementById('debug-console');
                if (existing) {
                    existing.remove();
                    return;
                }

                const console = document.createElement('div');
                console.id = 'debug-console';
                console.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    left: 20px;
                    width: 400px;
                    height: 300px;
                    background: rgba(0, 0, 0, 0.9);
                    color: white;
                    border-radius: 8px;
                    padding: 15px;
                    font-family: monospace;
                    font-size: 12px;
                    z-index: 10000;
                    overflow-y: auto;
                    direction: ltr;
                `;

                const header = document.createElement('div');
                header.style.cssText = `
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    margin-bottom: 10px;
                    padding-bottom: 10px;
                    border-bottom: 1px solid #333;
                `;
                header.innerHTML = `
                    <span>Debug Console (${this.logs.length} logs)</span>
                    <button onclick="debugManager.showDebugConsole()" style="background: none; border: none; color: white; cursor: pointer;">×</button>
                `;

                const logsList = document.createElement('div');
                logsList.style.cssText = `
                    max-height: 250px;
                    overflow-y: auto;
                `;

                this.logs.slice(-20).forEach(log => {
                    const logDiv = document.createElement('div');
                    logDiv.style.cssText = `
                        margin-bottom: 5px;
                        padding: 5px;
                        border-left: 3px solid ${this.getLevelColor(log.level)};
                        background: rgba(255, 255, 255, 0.1);
                    `;
                    logDiv.innerHTML = `
                        <div style="font-weight: bold;">[${log.level.toUpperCase()}] ${log.category}</div>
                        <div style="color: #ccc; font-size: 10px;">${log.timestamp}</div>
                        <div>${JSON.stringify(log.data, null, 2)}</div>
                    `;
                    logsList.appendChild(logDiv);
                });

                console.appendChild(header);
                console.appendChild(logsList);
                document.body.appendChild(console);
            }

            getLevelColor(level) {
                switch (level) {
                    case 'debug': return '#6b7280';
                    case 'info': return '#3b82f6';
                    case 'warn': return '#f59e0b';
                    case 'error': return '#ef4444';
                    default: return '#6b7280';
                }
            }

            sendToRemote(logEntry) {
                // Implementation for remote logging service
                // This would typically send to a logging service like LogRocket, Sentry, etc.
                console.debug('Would send to remote logging service:', logEntry);
            }

            // Get system information for debugging
            getSystemInfo() {
                return {
                    userAgent: navigator.userAgent,
                    language: navigator.language,
                    platform: navigator.platform,
                    cookieEnabled: navigator.cookieEnabled,
                    onLine: navigator.onLine,
                    screen: {
                        width: screen.width,
                        height: screen.height,
                        colorDepth: screen.colorDepth
                    },
                    window: {
                        innerWidth: window.innerWidth,
                        innerHeight: window.innerHeight
                    },
                    localStorage: typeof(Storage) !== "undefined",
                    indexedDB: typeof(indexedDB) !== "undefined"
                };
            }
        }

        // Initialize debug manager
        const debugManager = new DebugManager();

        // Add keyboard shortcut for debug console (Ctrl+Shift+D)
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && e.key === 'D') {
                e.preventDefault();
                debugManager.showDebugConsole();
            }
        });

        // Initialize tutorial system
        const tutorialSystem = new TutorialSystem();

        console.log('📝 Enhanced Manual Scheduler JavaScript loaded');
    </script>

    <!-- Help Overlay and Tutorial System -->
    <div id="help-overlay" class="help-overlay">
        <div id="help-step" class="help-step">
            <h4>ברוכים הבאים למדריך השיבוץ המשופר</h4>
            <p>במדריך זה תלמדו כיצד להשתמש במערכת השיבוץ החדשה</p>
            <div class="help-step-controls">
                <div class="help-step-nav">
                    <button id="help-prev" disabled>הקודם</button>
                    <button id="help-next">הבא</button>
                </div>
                <div class="help-step-indicator">
                    <span id="help-current-step">1</span> / <span id="help-total-steps">5</span>
                </div>
                <button id="help-close">סגור</button>
            </div>
        </div>
    </div>

    <!-- Tooltip Container -->
    <div id="tooltip" class="tooltip"></div>

</body>
</html>